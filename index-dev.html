<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- SEO Meta -->
  <title>Loop Runner â€” Free Browser Action Game | Playloop.run</title>
  <meta name="description" content="Dash, chain, and climb the leaderboard in Loop Runner â€” a free, fast-paced browser action game. Play instantly, no downloads required." />
  <link rel="canonical" href="https://playloop.run/">
  <meta name="robots" content="index,follow,max-image-preview:large">
  <meta name="keywords" content="free browser game, action game, leaderboard game, reflex game, playloop, loop runner, instant play game">
  <meta name="theme-color" content="#0b0b10">

  <!-- Social / Open Graph -->
  <meta property="og:title" content="Loop Runner â€” Free Browser Action Game">
  <meta property="og:description" content="Dash, chain, and climb the leaderboard in Loop Runner. A lightning-fast browser game â€” free to play, no downloads.">
  <meta property="og:url" content="https://playloop.run/">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Playloop">
  <meta property="og:locale" content="en_GB">
  <meta property="og:image" content="https://playloop.run/looprunner-preview.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Loop Runner â€” Free Browser Action Game">
  <meta name="twitter:description" content="Dash, chain, and climb the leaderboard in Loop Runner. Free, fast-paced, and playable instantly in your browser.">
  <meta name="twitter:image" content="https://playloop.run/looprunner-preview.png">

  <!-- PWA / Icons -->
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="favicon.ico">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">

  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Loop Runner",
    "url": "https://playloop.run/",
    "image": "https://playloop.run/looprunner-preview.png",
    "description": "Dash, chain, and climb the leaderboard in Loop Runner â€” a free, fast-paced browser action game you can play instantly.",
    "inLanguage": "en",
    "applicationCategory": "Game",
    "operatingSystem": "Web",
    "gamePlatform": "Browser",
    "playMode": ["SinglePlayer"],
    "publisher": { "@type": "Organization", "name": "Playloop" },
    "offers": { "@type": "Offer", "price": "0", "priceCurrency": "GBP" }
  }
  </script>

  <!-- Consent Mode v2 (default denied) -->
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('consent','default',{
      'ad_storage':'denied','ad_user_data':'denied','ad_personalization':'denied','analytics_storage':'denied'
    });
  </script>

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3857946786580406" crossorigin="anonymous"></script>

  <!-- Funding Choices (CMP) -->
  <script async src="https://fundingchoicesmessages.google.com/i/pub-3857946786580406?ers=1"></script>
  <script>
    (function signalGooglefcPresent() {
      if (!window.frames['googlefcPresent']) {
        function add(){const f=document.createElement('iframe');f.style='width:0;height:0;border:0;display:none';f.name='googlefcPresent';document.body.appendChild(f);}
        document.body ? add() : setTimeout(signalGooglefcPresent,0);
      }
    })();
  </script>

  <style>
    /* ========= theme (from wireframe) ========= */
    :root{
      --bg:#0b0b10; --fg:#eaecef; --muted:#9aa0a6; --accent:#6cf; --card:rgba(20,20,28,.85);
      --adCap: 90px; /* cap the ad height */
    }
    @media (max-width: 991px){ :root{ --adCap: 60px; } }
    @media (max-width: 599px){ :root{ --adCap: 50px; } }

    *{ box-sizing:border-box }
    html, body { height:100%; margin:0; overflow:hidden; background:var(--bg); color:var(--fg); font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial; }

    /* ========= Top Ad (hard-capped) ========= */
    #ad-top-wrapper{ position:fixed; top:0; left:0; right:0; z-index:30; background:rgba(0,0,0,.15); backdrop-filter:blur(3px); border-bottom:1px dashed #2a2f3a; display:flex; justify-content:center; padding:4px 8px 0; max-height:var(--adCap); overflow:hidden; }
    #ad-top-unit{ display:block !important; text-align:center; width:100% !important; height:var(--adCap) !important; line-height:0; }
    #ad-spacer{ height:var(--adH, var(--adCap)); }

    /* ========= Canvas ========= */
    canvas{ display:block; width:100vw; height:calc(100vh - var(--adH, var(--adCap))); image-rendering:crisp-edges; }

    /* ========= HUD ========= */
    #ui{ position:fixed; inset:0; pointer-events:none; }
    .hud{ position:absolute; left:12px; top:calc(var(--adH, var(--adCap)) + 12px); display:flex; gap:12px; align-items:center; }
    .pill{ background:#111826; border:1px solid #2e3240; padding:6px 10px; border-radius:999px; font-weight:600; letter-spacing:.3px; color:#c9d1d9; }

    /* ========= Overlay (wireframe style) ========= */
    #overlay{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; }
    #overlay.visible{ display:flex; }
    #overlayCard{ min-width:min(85%,520px); max-width:92%; border-radius:16px; padding:16px 18px; background:var(--card); box-shadow:0 10px 30px rgba(0,0,0,.35); outline:1px dashed #2e3240; }
    #overlayTitle{ font-size:18px; margin:0 0 8px }
    #overlayBody{ opacity:.9; margin-bottom:10px }
    #overlayRow{ display:flex; gap:8px; flex-wrap:wrap }

    /* ========= Buttons ========= */
    .btn, .cta{ pointer-events:auto; border:0; border-radius:12px; padding:.6rem .9rem; background:#1a1a22; color:#fff; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.2); }
    .cta{ position:relative; border-radius:14px; font-weight:800; display:inline-flex; align-items:center; gap:10px; letter-spacing:.3px; user-select:none; -webkit-tap-highlight-color:transparent; }
    .cta--primary{ background:linear-gradient(135deg,#2c7cf7,#7cfdd6 120%); color:#06101a; border:1px solid rgba(124,253,214,.25); }
    .cta--secondary{ background:linear-gradient(135deg,#ff7ab6,#ffd277 120%); color:#1a0b0f; border:1px solid rgba(255,210,119,.25); }

    /* ========= Enhanced UI Styles ========= */
    .cursor-indicator{ position:absolute; width:20px; height:20px; border:2px solid #88ffcc; border-radius:50%; pointer-events:none; z-index:25; opacity:0.8; }
    .chain-indicator{ position:absolute; border:2px dashed #ffd277; border-radius:50%; pointer-events:none; z-index:24; opacity:0.6; }
    .boss-health{ position:absolute; background:rgba(0,0,0,0.7); border:1px solid #ff4444; border-radius:4px; padding:2px 6px; font-size:10px; color:#fff; pointer-events:none; z-index:23; }
    .stats-grid{ display:grid; grid-template-columns:1fr 1fr; gap:8px; margin:12px 0; }
    .stat-item{ background:rgba(255,255,255,0.05); padding:8px; border-radius:6px; text-align:center; }
    .stat-value{ font-size:18px; font-weight:bold; color:#88ffcc; }
    .stat-label{ font-size:12px; opacity:0.8; }

    /* ========= Quickbar & Daily Banner ========= */
    #quickbar{ position:fixed; left:50%; transform:translateX(-50%); bottom:8px; display:flex; gap:8px; z-index:26; }
    #dailyBanner{ position:fixed; right:8px; bottom:8px; color:var(--muted); font-weight:600; z-index:26; background:#111826; border:1px solid #2e3240; padding:6px 10px; border-radius:10px; }

    /* ========= Modal (Leaderboard) ========= */
    .modal { pointer-events:auto; position: fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:28; }
    .modal.show { display:flex; }
    .sheet { width:min(560px, 92vw); background: rgba(0,0,0,0.6); backdrop-filter: blur(8px); border:1px solid rgba(255,255,255,0.1); border-radius:16px; padding:16px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
    .row { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
    table { width:100%; border-collapse: collapse; }
    th, td { text-align:left; padding:8px; border-bottom: 1px solid rgba(255,255,255,0.08); font-size:14px; }

    /* inputs */
    input[type="text"], select{ pointer-events:auto; background:#101823; border:1px solid #233146; color:#e6edf3; padding:10px 12px; border-radius:10px; outline:none; }
  </style>
</head>
<body>
  <!-- Top Ad (hard-capped) -->
  <div id="ad-top-wrapper">
    <ins id="ad-top-unit" class="adsbygoogle"
         style="display:block; text-align:center;"
         data-ad-client="ca-pub-3857946786580406"
         data-ad-slot="7067398117"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
  </div>
  <div id="ad-spacer"></div>

  <!-- Game Canvas -->
  <canvas id="game"></canvas>

  <!-- UI / HUD -->
  <div id="ui">
    <div class="hud">
      <div id="score" class="pill">Score: 0</div>
      <div id="combo" class="pill">Combo: 0</div>
      <div id="best" class="pill">Best: 0</div>
      <div id="daily" class="pill">Daily: 0</div>
      <a href="privacy.html" class="pill" style="text-decoration:none; pointer-events:auto;">Privacy</a>
      <button id="lbBtn" class="cta cta--secondary" style="pointer-events:auto;">Leaderboard</button>
    </div>

    <!-- Overlay (wireframe look, driven by game state) -->
    <div id="overlay" class="visible" role="dialog" aria-modal="true">
      <div id="overlayCard">
        <h3 id="overlayTitle">Loop Runner</h3>
        <div id="overlayBody">Dash through enemies. Click/tap to dash toward the pointer. Chain kills to build combo. Don't touch enemies while not dashing.</div>
        <div class="row" style="margin:8px 0;">
          <button id="start" class="cta cta--primary" aria-label="Play"><span aria-hidden="true">â–¶</span> Play</button>
          <button id="dailyBtn" class="cta cta--secondary" aria-label="Daily Run"><span aria-hidden="true">â˜€</span> Daily Run</button>
        </div>
        <div id="overlayRow" style="margin:8px 0 0 0;">
          <button class="btn" id="btnResume" style="display:none">â–¶ Resume</button>
          <button class="btn" id="btnPlayAgain" style="display:none">â†» Play Again</button>
          <button class="btn" id="btnShare">ðŸ“£ Share</button>
        </div>
        <div class="hint" style="opacity:.85; font-size:13px; margin-top:10px;">Controls: Click/Tap to dash â€¢ Space to restart â€¢ P / Esc to pause</div>
        <div style="margin-top:10px; opacity:.9; font-size:13px;">Name: <input id="nameInput" type="text" placeholder="Your name (for scores)" style="width:220px;" /></div>
      </div>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="lbModal" class="modal">
    <div class="sheet">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h2>Leaderboard</h2>
        <button id="lbClose" class="cta cta--secondary" style="padding:10px 14px;">Close</button>
      </div>
      <div style="margin: 8px 0;">
        <ins id="ad-modal-unit" class="adsbygoogle"
            style="display:block; text-align:center;"
            data-ad-client="ca-pub-3857946786580406"
            data-ad-slot="7067398117"
            data-ad-format="auto"
            data-full-width-responsive="true"></ins>
      </div>
      <div class="row" style="margin:8px 0 12px 0; align-items:center;">
        <select id="lbMode">
          <option value="normal">Normal</option>
          <option value="daily">Daily (today)</option>
        </select>
        <div id="lbInfo" style="opacity:.8; font-size:13px;"></div>
      </div>
      <table id="lbTable"><thead><tr><th style="width:56px;">#</th><th>Name</th><th>Score</th><th style="text-align:right;">Status</th></tr></thead><tbody></tbody></table>
    </div>
  </div>

  <!-- Quickbar + Daily Banner -->
  <div id="quickbar">
    <button id="restartBtn" class="cta cta--primary" style="padding:10px 14px;">â†» Restart</button>
    <button id="shareBtn" class="cta cta--secondary" style="padding:10px 14px;">ðŸ“£ Share</button>
  </div>
  <div id="dailyBanner">Daily Challenge</div>

<script>
(() => {
  console.log('Starting Loop Runner initialization...');
  
  const $ = (sel) => document.querySelector(sel);
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W=0, H=0, DPR=Math.min(devicePixelRatio||1,2);

  /* ====== layout sizing (ad-aware) ====== */
  function resize(){
    const spacer = document.getElementById('ad-spacer');
    const adH = (spacer && spacer.offsetHeight) || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--adH')) || 0;
    W = innerWidth|0;
    H = Math.max(0, (innerHeight|0) - adH);
    canvas.width  = Math.max(1, W*DPR);
    canvas.height = Math.max(1, H*DPR);
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize);

  const topIns = document.getElementById('ad-top-unit');
  function tryFillTopAd(){
    if(!topIns) return;
    const w = topIns.clientWidth;
    if(w && w > 0){ (window.adsbygoogle=window.adsbygoogle||[]).push({}); return true; }
    return false;
  }
  window.addEventListener('load', ()=>{
    let ok = tryFillTopAd();
    if(!ok){ const id = setInterval(()=>{ if(tryFillTopAd()) clearInterval(id); }, 200); setTimeout(()=> clearInterval(id), 5000); }
    resize();
  });

  const spacer = document.getElementById('ad-spacer');
  const topWrap = document.getElementById('ad-top-wrapper');
  function updateAdVars(){
    const h = (topWrap && topWrap.offsetHeight) || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--adCap')) || 0;
    spacer.style.height = h + 'px';
    document.documentElement.style.setProperty('--adH', h+'px');
    resize();
  }
  if('ResizeObserver' in window && topWrap){ new ResizeObserver(updateAdVars).observe(topWrap); } else { setTimeout(updateAdVars, 300); }

  /* ====== storage helpers ====== */
  function getLS(k, fallback){ try{ const v = localStorage.getItem(k); return v===null? fallback: v; }catch{ return fallback; } }
  function setLS(k, v){ try{ localStorage.setItem(k, v); }catch{} }

  /* ====== Real Location Detection ====== */
  let userCountry = null;
  let locationDetected = false;

  async function detectUserLocation() {
    if (locationDetected) return userCountry;
    
    try {
      console.log('Detecting user location...');
      const response = await fetch('https://ipapi.co/json/', {
        timeout: 5000
      });
      
      if (!response.ok) throw new Error('Location API failed');
      
      const data = await response.json();
      userCountry = data.country_code || 'XX';
      locationDetected = true;
      console.log('User location detected:', userCountry);
      return userCountry;
    } catch (error) {
      console.warn('Location detection failed:', error);
      userCountry = 'XX'; // Unknown location
      locationDetected = true;
      return userCountry;
    }
  }

  // Start location detection early
  detectUserLocation();

  /* ====== state ====== */
  const state={ 
    running:false, paused:false, score:0, combo:0, time:0,
    best:Number(getLS('lr_best', 0)), dailyBest:Number(getLS('lr_daily', 0)),
    spawnTimer:0, spawnInterval:1.1, dailyMode:false,
    // Enhanced stats
    enemiesKilled: 0, bossesKilled: 0, totalDashes: 0, perfectDashes: 0,
    // Fire rounds system
    fireRounds: 3,
    maxFireRounds: 3
  };

  /* ====== UI refs ====== */
  const ui={
    score:$('#score'), combo:$('#combo'), best:$('#best'), daily:$('#daily'),
    overlay:$('#overlay'),
    ovTitle:$('#overlayTitle'), ovBody:$('#overlayBody'),
    start:$('#start'), dailyBtn:$('#dailyBtn'),
    btnResume:$('#btnResume'), btnPlayAgain:$('#btnPlayAgain'), btnShare:$('#btnShare'),
    lbBtn:$('#lbBtn'), nameInput:$('#nameInput'),
    restartBtn:$('#restartBtn'), shareBtn:$('#shareBtn'),
    dailyBanner:$('#dailyBanner')
  };

  function hydrateHUD(){ 
    ui.score.textContent='Score: 0'; 
    ui.combo.textContent='Combo: 0'; 
    ui.best.textContent='Best: '+state.best; 
    ui.daily.textContent='Daily: '+state.dailyBest; 
  }
  hydrateHUD();
  ui.dailyBanner.textContent = 'Daily Challenge: ' + new Date().toISOString().slice(0,10);

  /* ====== Pause/Resume helpers (overlay driven) ====== */
  function showOverlay(){ ui.overlay.classList.add('visible'); }
  function hideOverlay(){ ui.overlay.classList.remove('visible'); }

  function setOverlayHome(){
    ui.ovTitle.textContent = 'Loop Runner';
    ui.ovBody.innerHTML = 'Player follows your mouse cursor. <strong>Right-click to fire</strong> (3 rounds, recharges every 2 seconds). Chain kills to build combo. Don\'t touch enemies while not dashing.';
    ui.btnResume.style.display = 'none';
    ui.btnPlayAgain.style.display = 'none';
    showOverlay();
  }
  function setOverlayPaused(){
    ui.ovTitle.textContent = 'Paused';
    ui.ovBody.innerHTML = 'Press <b>P</b> or <b>Esc</b> to resume';
    ui.btnResume.style.display = '';
    ui.btnPlayAgain.style.display = '';
    showOverlay();
  }
  function setOverlayGameOver(score, best, isPB){
    ui.ovTitle.textContent = isPB ? 'New Best!' : 'Game Over';
    
    // Enhanced game over screen with stats
    const minutes = Math.floor(state.time / 60);
    const seconds = Math.floor(state.time % 60);
    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    ui.ovBody.innerHTML = `
      <div style="text-align:center; margin-bottom:12px;">
        Score: <strong>${score}</strong> â€¢ Best: <strong>${best}</strong>${isPB?' â€¢ ðŸŽ‰':''}
      </div>
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-value">${state.enemiesKilled}</div>
          <div class="stat-label">Enemies Killed</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">${state.combo}</div>
          <div class="stat-label">Best Combo</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">${state.bossesKilled}</div>
          <div class="stat-label">Bosses Killed</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">${state.totalDashes}</div>
          <div class="stat-label">Total Dashes</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">${state.perfectDashes}</div>
          <div class="stat-label">Perfect Dashes</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">${timeStr}</div>
          <div class="stat-label">Game Time</div>
        </div>
      </div>
    `;
    ui.btnResume.style.display = 'none';
    ui.btnPlayAgain.style.display = '';
    showOverlay();
  }

  /* ====== RNG ====== */
  const todayKey=()=>new Date().toISOString().slice(0,10);
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}};
  let seededRand=Math.random; let usingSeed=false;
  function setDailySeed(){ usingSeed=true; seededRand=mulberry32(hashToInt('looprunner:'+todayKey())); }
  function rnd(a=0,b=1){ return (usingSeed?seededRand():Math.random())*(b-a)+a; }
  function rndi(a,b){ return Math.floor(rnd(a,b+1)); }
  function hashToInt(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619); } return h>>>0; }

  /* ====== Audio ====== */
  let audio, master;
  function initAudio(){ if(!audio){ audio=new (window.AudioContext||window.webkitAudioContext)(); master=audio.createGain(); master.gain.value=0.08; master.connect(audio.destination); } }

  /* ====== Entities ====== */
  const player={ x:W/2, y:H/2, r:12, vx:0, vy:0, maxSpeed:900, friction:9, dashing:false, dashCooldown:0, dashWindup:0 };
  const enemies=[];
  const particles=[];
  const bosses=[];
  const projectiles=[];
  const powerUps=[];
  const backgroundParticles=[];

  // Initialize background particles
  function initBackgroundParticles() {
    backgroundParticles.length = 0;
    for(let i = 0; i < 50; i++) {
      backgroundParticles.push({
        x: rnd(0, W),
        y: rnd(0, H),
        vx: rnd(-20, 20),
        vy: rnd(-20, 20),
        size: rnd(1, 3),
        alpha: rnd(0.1, 0.3),
        color: `hsl(${rnd(200, 280)}, 70%, 60%)`
      });
    }
  }

  function addParticle(x,y,size=2,life=0.4){ 
    const a=rnd(0,Math.PI*2); 
    const sp=rnd(40,240); 
    particles.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life, maxLife:life, size}); 
  }

  function spawnEnemy(){ 
    const m=24; 
    const side=rndi(0,3); 
    let x,y; 
    if(side===0){x=rnd(-m,W+m); y=-m;} 
    else if(side===1){x=W+m; y=rnd(-m,H+m);} 
    else if(side===2){x=rnd(-m,W+m); y=H+m;} 
    else {x=-m; y=rnd(-m,H+m);} 
    const r=rnd(14,22); 
    const speed=rnd(40,90)+Math.min(state.time*4,220); 
    const ang=Math.atan2(player.y-y, player.x-x)+rnd(-0.5,0.5); 
    const vx=Math.cos(ang)*speed, vy=Math.sin(ang)*speed; 
    enemies.push({x,y,r,vx,vy,speed,ang}); 
  }

  function spawnBoss() {
    const m = 30;
    const side = rndi(0, 3);
    let x, y;
    if(side === 0) { x = rnd(-m, W+m); y = -m; }
    else if(side === 1) { x = W+m; y = rnd(-m, H+m); }
    else if(side === 2) { x = rnd(-m, W+m); y = H+m; }
    else { x = -m; y = rnd(-m, H+m); }
    
    const r = 35;
    const speed = rnd(30, 60) + Math.min(state.time * 2, 100);
    const ang = Math.atan2(player.y - y, player.x - x);
    const vx = Math.cos(ang) * speed;
    const vy = Math.sin(ang) * speed;
    
    bosses.push({
      x, y, r, vx, vy, speed, ang,
      health: 5,
      maxHealth: 5,
      lastHit: 0
    });
  }

  function fireBurst() {
    console.log('Fire burst activated!');
    if(state.fireRounds <= 0) {
      console.log('No fire rounds left!');
      return; // No rounds left
    }
    
    state.fireRounds--;
    console.log('Fire rounds remaining:', state.fireRounds);
    const projectileCount = 10;
    for(let i = 0; i < projectileCount; i++) {
      const angle = (i / projectileCount) * Math.PI * 2;
      const speed = 400;
      projectiles.push({
        x: player.x,
        y: player.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 2.0,
        maxLife: 2.0,
        size: 4
      });
    }
    
    // Add burst effect particles
    for(let i = 0; i < 20; i++) {
      addParticle(player.x, player.y, rnd(2, 5), rnd(0.3, 0.6));
    }
  }

  /* ====== Input ====== */
  let pointer={ x:W/2, y:H/2, down:false };
  let cursorIndicator = null;

  function screenToWorld(e){ 
    const rect=canvas.getBoundingClientRect(); 
    return { x:(e.clientX-rect.left), y:(e.clientY-rect.top) }; 
  }

  function startDashTowards(px,py){ 
    if(player.dashCooldown>0) return; 
    const dx=px-player.x, dy=py-player.y; 
    const len=Math.hypot(dx,dy)||1; 
    const ux=dx/len, uy=dy/len; 
    player.vx=ux*player.maxSpeed; 
    player.vy=uy*player.maxSpeed; 
    player.dashing=true; 
    player.dashCooldown=0.35; 
    player.dashWindup=0.12; 
    state.totalDashes++;
    
    // Check for perfect dash (hitting enemy immediately)
    let hitEnemy = false;
    for(const e of enemies) {
      const d = Math.hypot(e.x - player.x, e.y - player.y);
      if(d < e.r + player.r + 20) {
        hitEnemy = true;
        break;
      }
    }
    if(hitEnemy) state.perfectDashes++;
    
    for(let i=0;i<10;i++) addParticle(player.x,player.y,3,0.25); 
  }

  // Mouse controls
  canvas.addEventListener('pointerdown',(e)=>{
    initAudio();
    if(e.button === 2) { // Right click
      e.preventDefault();
      fireBurst();
    }
  });

  canvas.addEventListener('pointermove',(e)=>{ 
    const p=screenToWorld(e); 
    pointer.x=p.x; 
    pointer.y=p.y; 
  });

  canvas.addEventListener('pointerup',()=>{ 
    pointer.down=false; 
  });

  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault(); // Prevent context menu
  });

  // Keyboard controls
  addEventListener('keydown',(e)=>{
    if(e.repeat) return;
    
    // Fire burst
    if(e.key === 'f' || e.key === 'F') {
      e.preventDefault();
      fireBurst();
      return;
    }
    
    if(e.code==='Space'){ 
      if(!state.running){ 
        e.preventDefault(); 
        startGame(state.dailyMode); 
        return; 
      } 
    }
    if(e.key==='r' || e.key==='R'){ 
      e.preventDefault(); 
      startGame(state.dailyMode); 
      return; 
    }
    if(e.key==='p' || e.key==='P' || e.key==='Escape'){ 
      e.preventDefault(); 
      if(state.running){ 
        if(!state.paused) pauseGameUI(); 
        else resumeGameUI(); 
      } 
      return; 
    }
    
    // Arrow key dashing
    const amt=80; 
    if(e.key&&e.key.indexOf('Arrow')===0){ 
      let dx=0, dy=0; 
      if(e.key==='ArrowUp') dy=-amt; 
      else if(e.key==='ArrowDown') dy=amt; 
      else if(e.key==='ArrowLeft') dx=-amt; 
      else if(e.key==='ArrowRight') dx=amt; 
      startDashTowards(player.x+dx, player.y+dy);
    }
  });

  addEventListener('blur', ()=>{ 
    if(state.running && !state.paused) pauseGameUI(); 
  });

  /* ====== Leaderboard ====== */
  const lb={ modal:$('#lbModal'), close:$('#lbClose'), modeSel:$('#lbMode'), info:$('#lbInfo'), table:$('#lbTable').querySelector('tbody') };
  function loadLB(key){ try{ return JSON.parse(getLS(key,'[]')); }catch{ return []; } }
  function saveLB(key,arr){ setLS(key, JSON.stringify(arr)); }

  const SB_URL = 'https://zpoerliqhcywaulbthyf.supabase.co/rest/v1/scores';
  const SB_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpwb2VybGlxaGN5d2F1bGJ0aHlmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgyMDQxNjYsImV4cCI6MjA3Mzc4MDE2Nn0.7jjITj1H2AxWPnCeyzmMsNw3uAVACoYb_CV5rRoD65k';
  const SB_HEADERS = { 'apikey': SB_KEY, 'Authorization': 'Bearer '+SB_KEY, 'Content-Type': 'application/json' };

  function showLeaderboard(mode){ 
    lb.modal.classList.add('show'); 
    lb.modeSel.value = mode || (state.dailyMode?'daily':'normal'); 
    renderLeaderboard(); 
    maybeFillModalAd(); 
  }
  function hideLeaderboard(){ 
    lb.modal.classList.remove('show'); 
  }

  function renderLeaderboard(){
    const mode = lb.modeSel.value;
    const key = mode === 'daily' ? 'lr_lb_daily_' + todayKey() : 'lr_lb_normal';
    const scores = loadLB(key);
    
    lb.info.textContent = mode === 'daily' ? `Today (${todayKey()})` : 'All Time';
    
    lb.table.innerHTML = '';
    scores.slice(0, 20).forEach((entry, i) => {
      const row = document.createElement('tr');
      const isYou = entry.name === (ui.nameInput.value || 'Anonymous');
      if(isYou) row.style.background = 'rgba(124, 253, 214, 0.1)';
      
      row.innerHTML = `
        <td>${i + 1}</td>
        <td>${entry.name || 'Anonymous'}</td>
        <td>${entry.score}</td>
        <td style="text-align:right;">${isYou ? 'You' : ''}</td>
      `;
      lb.table.appendChild(row);
    });
    
    if(scores.length === 0) {
      const row = document.createElement('tr');
      row.innerHTML = '<td colspan="4" style="text-align:center; opacity:0.6;">No scores yet</td>';
      lb.table.appendChild(row);
    }
  }

  async function submitScore(score, mode) {
    const name = ui.nameInput.value.trim() || 'Anonymous';
    const key = mode === 'daily' ? 'lr_lb_daily_' + todayKey() : 'lr_lb_normal';
    
    // Local leaderboard
    const scores = loadLB(key);
    scores.push({ name, score, timestamp: Date.now() });
    scores.sort((a, b) => b.score - a.score);
    saveLB(key, scores.slice(0, 100));
    
    // Online leaderboard
    try {
      await detectUserLocation(); // Ensure location is detected
      
      const payload = {
        name: name,
        score: score,
        mode: mode,
        country: userCountry || 'XX',
        date: mode === 'daily' ? todayKey() : null
      };
      
      console.log('Submitting score:', payload);
      
      const response = await fetch(SB_URL, {
        method: 'POST',
        headers: SB_HEADERS,
        body: JSON.stringify(payload)
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Score submission failed:', response.status, errorText);
      } else {
        console.log('Score submitted successfully');
      }
    } catch(err) { 
      console.error('submitScore exception', err); 
    }
  }

  ui.start.addEventListener('click', ()=>{ initAudio(); startGame(false); });
  ui.dailyBtn.addEventListener('click', ()=>{ initAudio(); startGame(true); });
  ui.btnResume.addEventListener('click', resumeGameUI);
  ui.btnPlayAgain.addEventListener('click', ()=>{ startGame(state.dailyMode); });
  ui.btnShare.addEventListener('click', shareScore);
  ui.restartBtn.addEventListener('click', ()=>{ startGame(state.dailyMode); });
  ui.shareBtn.addEventListener('click', shareScore);
  ui.lbBtn.addEventListener('click', ()=>{ showLeaderboard(); });
  lb.close.addEventListener('click', hideLeaderboard);
  lb.modeSel.addEventListener('change', renderLeaderboard);

  function shareScore(){
    const text = state.dailyMode 
      ? `I scored ${state.score} in today's Loop Runner daily challenge! Can you beat it?`
      : `I scored ${state.score} in Loop Runner! Can you beat my score?`;
    const url = 'https://playloop.run/';
    
    if(navigator.share) {
      navigator.share({ title: 'Loop Runner', text, url }).catch(()=>{});
    } else {
      navigator.clipboard?.writeText(`${text} ${url}`).then(()=>{
        // Could show a toast here
      }).catch(()=>{});
    }
  }

  function maybeFillModalAd(){
    const modalIns = document.getElementById('ad-modal-unit');
    if(!modalIns) return;
    try { (window.adsbygoogle=window.adsbygoogle||[]).push({}); } catch(e) {}
  }

  /* ====== Game Logic ====== */
  let lastTime = 0;
  let fireRechargeTimer = 0;

  function startGame(daily) {
    console.log('Starting game, daily mode:', daily);
    state.dailyMode = daily;
    state.running = true;
    state.paused = false;
    state.score = 0;
    state.combo = 0;
    state.time = 0;
    state.spawnTimer = 0;
    state.spawnInterval = 1.1;
    state.enemiesKilled = 0;
    state.bossesKilled = 0;
    state.totalDashes = 0;
    state.perfectDashes = 0;
    state.fireRounds = state.maxFireRounds;
    fireRechargeTimer = 0;
    
    if(daily) setDailySeed();
    else { usingSeed = false; seededRand = Math.random; }
    
    player.x = W/2;
    player.y = H/2;
    player.vx = 0;
    player.vy = 0;
    player.dashing = false;
    player.dashCooldown = 0;
    player.dashWindup = 0;
    
    enemies.length = 0;
    particles.length = 0;
    bosses.length = 0;
    projectiles.length = 0;
    powerUps.length = 0;
    
    initBackgroundParticles();
    hideOverlay();
    
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  function pauseGameUI() {
    if(!state.running) return;
    state.paused = true;
    setOverlayPaused();
  }

  function resumeGameUI() {
    if(!state.running || !state.paused) return;
    state.paused = false;
    hideOverlay();
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  function endGame() {
    state.running = false;
    state.paused = false;
    
    const currentBest = state.dailyMode ? state.dailyBest : state.best;
    const isPB = state.score > currentBest;
    
    if(isPB) {
      if(state.dailyMode) {
        state.dailyBest = state.score;
        setLS('lr_daily', state.score);
      } else {
        state.best = state.score;
        setLS('lr_best', state.score);
      }
      hydrateHUD();
    }
    
    submitScore(state.score, state.dailyMode ? 'daily' : 'normal');
    setOverlayGameOver(state.score, Math.max(currentBest, state.score), isPB);
  }

  function gameLoop(currentTime) {
    if(!state.running || state.paused) return;
    
    const dt = Math.min((currentTime - lastTime) / 1000, 1/30);
    lastTime = currentTime;
    
    update(dt);
    render();
    
    requestAnimationFrame(gameLoop);
  }

  function update(dt) {
    state.time += dt;
    
    // Fire recharge system
    fireRechargeTimer += dt;
    if(fireRechargeTimer >= 2.0 && state.fireRounds < state.maxFireRounds) {
      state.fireRounds++;
      fireRechargeTimer = 0;
      console.log('Fire round recharged! Total:', state.fireRounds);
    }
    
    // Update player
    if(player.dashCooldown > 0) player.dashCooldown -= dt;
    if(player.dashWindup > 0) player.dashWindup -= dt;
    else player.dashing = false;
    
    // Player movement towards pointer
    if(!player.dashing) {
      const dx = pointer.x - player.x;
      const dy = pointer.y - player.y;
      const dist = Math.hypot(dx, dy);
      
      if(dist > 5) {
        const speed = Math.min(300, dist * 3);
        player.vx += (dx / dist) * speed * dt * 2;
        player.vy += (dy / dist) * speed * dt * 2;
      }
    }
    
    // Apply friction
    player.vx *= Math.pow(0.1, dt * player.friction);
    player.vy *= Math.pow(0.1, dt * player.friction);
    
    // Move player
    player.x += player.vx * dt;
    player.y += player.vy * dt;
    
    // Keep player in bounds
    player.x = Math.max(player.r, Math.min(W - player.r, player.x));
    player.y = Math.max(player.r, Math.min(H - player.r, player.y));
    
    // Spawn enemies
    state.spawnTimer += dt;
    if(state.spawnTimer >= state.spawnInterval) {
      state.spawnTimer = 0;
      state.spawnInterval = Math.max(0.3, 1.1 - state.time * 0.02);
      
      // Occasionally spawn boss
      if(rnd() < 0.1 && state.time > 10) {
        spawnBoss();
      } else {
        spawnEnemy();
      }
    }
    
    // Update enemies
    for(let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      e.x += e.vx * dt;
      e.y += e.vy * dt;
      
      // Remove if too far off screen
      if(e.x < -100 || e.x > W + 100 || e.y < -100 || e.y > H + 100) {
        enemies.splice(i, 1);
        continue;
      }
      
      // Check collision with player
      const dist = Math.hypot(e.x - player.x, e.y - player.y);
      if(dist < e.r + player.r) {
        if(player.dashing) {
          // Kill enemy
          enemies.splice(i, 1);
          state.score += 10 + state.combo;
          state.combo++;
          state.enemiesKilled++;
          
          // Particles
          for(let j = 0; j < 8; j++) {
            addParticle(e.x, e.y, rnd(2, 4), rnd(0.3, 0.5));
          }
        } else {
          // Game over
          endGame();
          return;
        }
      }
    }
    
    // Update bosses
    for(let i = bosses.length - 1; i >= 0; i--) {
      const b = bosses[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      
      // Remove if too far off screen
      if(b.x < -100 || b.x > W + 100 || b.y < -100 || b.y > H + 100) {
        bosses.splice(i, 1);
        continue;
      }
      
      // Check collision with player
      const dist = Math.hypot(b.x - player.x, b.y - player.y);
      if(dist < b.r + player.r) {
        if(player.dashing && performance.now() - b.lastHit > 200) {
          // Damage boss
          b.health--;
          b.lastHit = performance.now();
          
          if(b.health <= 0) {
            // Kill boss
            bosses.splice(i, 1);
            state.score += 50 + state.combo * 2;
            state.combo += 3;
            state.bossesKilled++;
            
            // Big particle explosion
            for(let j = 0; j < 15; j++) {
              addParticle(b.x, b.y, rnd(3, 6), rnd(0.4, 0.7));
            }
          } else {
            // Damage particles
            for(let j = 0; j < 5; j++) {
              addParticle(b.x, b.y, rnd(2, 4), rnd(0.2, 0.4));
            }
          }
        } else if(!player.dashing) {
          // Game over
          endGame();
          return;
        }
      }
    }
    
    // Update projectiles
    for(let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      
      if(p.life <= 0 || p.x < -50 || p.x > W + 50 || p.y < -50 || p.y > H + 50) {
        projectiles.splice(i, 1);
        continue;
      }
      
      // Check collision with enemies
      for(let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        const dist = Math.hypot(p.x - e.x, p.y - e.y);
        if(dist < p.size + e.r) {
          // Kill enemy
          enemies.splice(j, 1);
          projectiles.splice(i, 1);
          state.score += 15 + state.combo;
          state.combo++;
          state.enemiesKilled++;
          
          // Particles
          for(let k = 0; k < 6; k++) {
            addParticle(e.x, e.y, rnd(2, 4), rnd(0.3, 0.5));
          }
          break;
        }
      }
      
      // Check collision with bosses
      for(let j = bosses.length - 1; j >= 0; j--) {
        const b = bosses[j];
        const dist = Math.hypot(p.x - b.x, p.y - b.y);
        if(dist < p.size + b.r) {
          // Damage boss
          projectiles.splice(i, 1);
          b.health--;
          
          if(b.health <= 0) {
            // Kill boss
            bosses.splice(j, 1);
            state.score += 60 + state.combo * 2;
            state.combo += 4;
            state.bossesKilled++;
            
            // Big particle explosion
            for(let k = 0; k < 15; k++) {
              addParticle(b.x, b.y, rnd(3, 6), rnd(0.4, 0.7));
            }
          } else {
            // Damage particles
            for(let k = 0; k < 5; k++) {
              addParticle(b.x, b.y, rnd(2, 4), rnd(0.2, 0.4));
            }
          }
          break;
        }
      }
    }
    
    // Update particles
    for(let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      p.vx *= 0.98;
      p.vy *= 0.98;
      
      if(p.life <= 0) {
        particles.splice(i, 1);
      }
    }
    
    // Update background particles
    for(const p of backgroundParticles) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      
      // Wrap around screen
      if(p.x < 0) p.x = W;
      if(p.x > W) p.x = 0;
      if(p.y < 0) p.y = H;
      if(p.y > H) p.y = 0;
    }
    
    // Update HUD
    ui.score.textContent = `Score: ${state.score}`;
    ui.combo.textContent = `Combo: ${state.combo}`;
  }

  function render() {
    // Clear canvas
    ctx.fillStyle = '#0b0b10';
    ctx.fillRect(0, 0, W, H);
    
    // Draw background particles
    for(const p of backgroundParticles) {
      ctx.globalAlpha = p.alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    
    // Draw cursor indicator
    ctx.strokeStyle = '#88ffcc';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(pointer.x, pointer.y, 15, 0, Math.PI * 2);
    ctx.stroke();
    
    // Draw chain indicator if combo > 0
    if(state.combo > 0) {
      ctx.strokeStyle = '#ffd277';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r + 10 + state.combo * 2, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    
    // Draw enemies
    for(const e of enemies) {
      ctx.fillStyle = player.dashing ? '#ff6b6b' : '#ff4757';
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
      ctx.fill();
      
      // Enemy glow
      ctx.shadowColor = '#ff4757';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r * 0.7, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    // Draw bosses
    for(const b of bosses) {
      ctx.fillStyle = '#8b00ff';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
      
      // Boss glow
      ctx.shadowColor = '#8b00ff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r * 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Health bar
      const barWidth = 40;
      const barHeight = 4;
      const healthPercent = b.health / b.maxHealth;
      
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(b.x - barWidth/2, b.y - b.r - 15, barWidth, barHeight);
      
      ctx.fillStyle = healthPercent > 0.5 ? '#4ade80' : healthPercent > 0.25 ? '#fbbf24' : '#ef4444';
      ctx.fillRect(b.x - barWidth/2, b.y - b.r - 15, barWidth * healthPercent, barHeight);
    }
    
    // Draw projectiles
    for(const p of projectiles) {
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#88ffcc';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Projectile trail
      ctx.shadowColor = '#88ffcc';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.globalAlpha = 1;
    
    // Draw particles
    for(const p of particles) {
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#88ffcc';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    
    // Draw player
    const playerColor = player.dashing ? '#7cfdd6' : '#88ffcc';
    ctx.fillStyle = playerColor;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
    ctx.fill();
    
    // Player glow
    ctx.shadowColor = playerColor;
    ctx.shadowBlur = player.dashing ? 20 : 10;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r * 0.7, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Draw fire rounds indicator
    const roundSize = 8;
    const roundSpacing = 20;
    const startX = 20;
    const startY = H - 30;
    
    for(let i = 0; i < state.maxFireRounds; i++) {
      ctx.fillStyle = i < state.fireRounds ? '#ffd277' : 'rgba(255, 210, 119, 0.3)';
      ctx.beginPath();
      ctx.arc(startX + i * roundSpacing, startY, roundSize, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Fire rounds label
    ctx.fillStyle = '#fff';
    ctx.font = '12px system-ui';
    ctx.fillText('Fire Rounds', startX, startY - 20);
  }

  // Initialize
  resize();
  setOverlayHome();
  
  // Load saved name
  ui.nameInput.value = getLS('lr_name', '');
  ui.nameInput.addEventListener('input', () => {
    setLS('lr_name', ui.nameInput.value);
  });

})();
</script>
</body>
</html>