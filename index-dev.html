<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- SEO Meta -->
  <title>Loop Runner DEV — Development Version</title>
  <meta name="description" content="Development version of Loop Runner for testing new features." />
  <link rel="canonical" href="https://playloop.run/">
  <meta name="robots" content="index,follow,max-image-preview:large">
  <meta name="keywords" content="free browser game, action game, leaderboard game, reflex game, playloop, loop runner, instant play game">
  <meta name="theme-color" content="#0b0b10">

  <!-- Social / Open Graph -->
  <meta property="og:title" content="Loop Runner DEV — Development Version">
  <meta property="og:description" content="Dash, chain, and climb the leaderboard in Loop Runner. A lightning-fast browser game — free to play, no downloads.">
  <meta property="og:url" content="https://playloop.run/">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Playloop">
  <meta property="og:locale" content="en_GB">
  <meta property="og:image" content="https://playloop.run/looprunner-preview.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Loop Runner DEV — Development Version">
  <meta name="twitter:description" content="Dash, chain, and climb the leaderboard in Loop Runner. Free, fast-paced, and playable instantly in your browser.">
  <meta name="twitter:image" content="https://playloop.run/looprunner-preview.png">

  <!-- PWA / Icons -->
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="favicon.ico">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">

  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Loop Runner",
    "url": "https://playloop.run/",
    "image": "https://playloop.run/looprunner-preview.png",
    "description": "Dash, chain, and climb the leaderboard in Loop Runner — a free, fast-paced browser action game you can play instantly.",
    "inLanguage": "en",
    "applicationCategory": "Game",
    "operatingSystem": "Web",
    "gamePlatform": "Browser",
    "playMode": ["SinglePlayer"],
    "publisher": { "@type": "Organization", "name": "Playloop" },
    "offers": { "@type": "Offer", "price": "0", "priceCurrency": "GBP" }
  }
  </script>

  <!-- Consent Mode v2 (default denied) -->
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('consent','default',{
      'ad_storage':'denied','ad_user_data':'denied','ad_personalization':'denied','analytics_storage':'denied'
    });
  </script>

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3857946786580406" crossorigin="anonymous"></script>

  <!-- Funding Choices (CMP) -->
  <script async src="https://fundingchoicesmessages.google.com/i/pub-3857946786580406?ers=1"></script>
  <script>
    (function signalGooglefcPresent() {
      if (!window.frames['googlefcPresent']) {
        function add(){const f=document.createElement('iframe');f.style='width:0;height:0;border:0;display:none';f.name='googlefcPresent';document.body.appendChild(f);}
        document.body ? add() : setTimeout(signalGooglefcPresent,0);
      }
    })();
  </script>

  <style>
    /* ========= theme (from wireframe) ========= */
    :root{
      --bg:#0b0b10; --fg:#eaecef; --muted:#9aa0a6; --accent:#6cf; --card:rgba(20,20,28,.85);
      --adCap: 90px; /* cap the ad height */
      /* DEV MODE STYLING */
      --dev-border: 3px solid #ff6b6b;
      --dev-bg: rgba(255, 107, 107, 0.1);
    }
    @media (max-width: 991px){ :root{ --adCap: 60px; } }
    @media (max-width: 599px){ :root{ --adCap: 50px; } }

    *{ box-sizing:border-box }
    html, body { height:100%; margin:0; overflow:hidden; background:var(--bg); color:var(--fg); font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial; }

    /* DEV MODE INDICATOR */
    body::before {
      content: "🚧 DEVELOPMENT VERSION 🚧";
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #ff6b6b;
      color: white;
      text-align: center;
      padding: 4px;
      font-weight: bold;
      font-size: 12px;
      z-index: 1000;
      letter-spacing: 1px;
    }

    /* ========= Top Ad (hard-capped) ========= */
    #ad-top-wrapper{ position:fixed; top:20px; left:0; right:0; z-index:30; background:rgba(0,0,0,.15); backdrop-filter:blur(3px); border-bottom:1px dashed #2a2f3a; display:flex; justify-content:center; padding:4px 8px 0; max-height:var(--adCap); overflow:hidden; }
    #ad-top-unit{ display:block !important; text-align:center; width:100% !important; height:var(--adCap) !important; line-height:0; }
    #ad-spacer{ height:calc(var(--adH, var(--adCap)) + 20px); }

    /* ========= Canvas ========= */
    canvas{ display:block; width:100vw; height:calc(100vh - var(--adH, var(--adCap))); image-rendering:crisp-edges; }

    /* ========= HUD ========= */
    #ui{ position:fixed; inset:0; pointer-events:none; }
    .hud{ position:absolute; left:12px; top:calc(var(--adH, var(--adCap)) + 32px); display:flex; gap:12px; align-items:center; }
    .pill{ background:#111826; border:1px solid #2e3240; padding:6px 10px; border-radius:999px; font-weight:600; letter-spacing:.3px; color:#c9d1d9; }

    /* ========= Overlay (wireframe style) ========= */
    #overlay{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; }
    #overlay.visible{ display:flex; }
    #overlayCard{ min-width:min(85%,520px); max-width:92%; border-radius:16px; padding:16px 18px; background:var(--card); box-shadow:0 10px 30px rgba(0,0,0,.35); outline:1px dashed #2e3240; border: var(--dev-border); }
    #overlayTitle{ font-size:18px; margin:0 0 8px }
    #overlayBody{ opacity:.9; margin-bottom:10px }
    #overlayRow{ display:flex; gap:8px; flex-wrap:wrap }

    /* ========= Buttons ========= */
    .btn, .cta{ pointer-events:auto; border:0; border-radius:12px; padding:.6rem .9rem; background:#1a1a22; color:#fff; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.2); }
    .cta{ position:relative; border-radius:14px; font-weight:800; display:inline-flex; align-items:center; gap:10px; letter-spacing:.3px; user-select:none; -webkit-tap-highlight-color:transparent; }
    .cta--primary{ background:linear-gradient(135deg,#2c7cf7,#7cfdd6 120%); color:#06101a; border:1px solid rgba(124,253,214,.25); }
    .cta--secondary{ background:linear-gradient(135deg,#ff7ab6,#ffd277 120%); color:#1a0b0f; border:1px solid rgba(255,210,119,.25); }

    /* ========= Quickbar & Daily Banner ========= */
    #quickbar{ position:fixed; left:50%; transform:translateX(-50%); bottom:8px; display:flex; gap:8px; z-index:26; }
    #dailyBanner{ position:fixed; right:8px; bottom:8px; color:var(--muted); font-weight:600; z-index:26; background:#111826; border:1px solid #2e3240; padding:6px 10px; border-radius:10px; }

    /* ========= Modal (Leaderboard) ========= */
    .modal { pointer-events:auto; position: fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:28; }
    .modal.show { display:flex; }
    .sheet { width:min(560px, 92vw); background: rgba(0,0,0,0.6); backdrop-filter: blur(8px); border:1px solid rgba(255,255,255,0.1); border-radius:16px; padding:16px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
    .row { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
    table { width:100%; border-collapse: collapse; }
    th, td { text-align:left; padding:8px; border-bottom: 1px solid rgba(255,255,255,0.08); font-size:14px; }

    /* inputs */
    input[type="text"], select{ pointer-events:auto; background:#101823; border:1px solid #233146; color:#e6edf3; padding:10px 12px; border-radius:10px; outline:none; }
  </style>
</head>
<body>
  <!-- Top Ad (hard-capped) -->
  <div id="ad-top-wrapper">
    <ins id="ad-top-unit" class="adsbygoogle"
         style="display:block; text-align:center;"
         data-ad-client="ca-pub-3857946786580406"
         data-ad-slot="7067398117"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
  </div>
  <div id="ad-spacer"></div>

  <!-- Game Canvas -->
  <canvas id="game"></canvas>

  <!-- UI / HUD -->
  <div id="ui">
    <div class="hud">
      <div id="score" class="pill">Score: 0</div>
      <div id="combo" class="pill">Combo: 0</div>
      <div id="best" class="pill">Best: 0</div>
      <div id="daily" class="pill">Daily: 0</div>
      <a href="privacy.html" class="pill" style="text-decoration:none; pointer-events:auto;">Privacy</a>
      <button id="lbBtn" class="cta cta--secondary" style="pointer-events:auto;">Leaderboard</button>
    </div>

    <!-- Overlay (wireframe look, driven by game state) -->
    <div id="overlay" class="visible" role="dialog" aria-modal="true">
      <div id="overlayCard">
        <h3 id="overlayTitle">Loop Runner DEV</h3>
        <div id="overlayBody">🚧 Development Version - Testing new features! 🚧<br><br>Dash through enemies. Click/tap to dash toward the pointer. Chain kills to build combo. Don't touch enemies while not dashing.</div>
        <div class="row" style="margin:8px 0;">
          <button id="start" class="cta cta--primary" aria-label="Play"><span aria-hidden="true">▶</span> Play</button>
          <button id="dailyBtn" class="cta cta--secondary" aria-label="Daily Run"><span aria-hidden="true">☀</span> Daily Run</button>
        </div>
        <div id="overlayRow" style="margin:8px 0 0 0;">
          <button class="btn" id="btnResume" style="display:none">▶ Resume</button>
          <button class="btn" id="btnPlayAgain" style="display:none">↻ Play Again</button>
          <button class="btn" id="btnShare">📣 Share</button>
        </div>
        <div class="hint" style="opacity:.85; font-size:13px; margin-top:10px;">Controls: Click/Tap to dash • Space to restart • P / Esc to pause</div>
        <div style="margin-top:10px; opacity:.9; font-size:13px;">Name: <input id="nameInput" type="text" placeholder="Your name (for scores)" style="width:220px;" /></div>
      </div>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="lbModal" class="modal">
    <div class="sheet">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h2>Leaderboard</h2>
        <button id="lbClose" class="cta cta--secondary" style="padding:10px 14px;">Close</button>
      </div>
      <div style="margin: 8px 0;">
        <ins id="ad-modal-unit" class="adsbygoogle"
            style="display:block; text-align:center;"
            data-ad-client="ca-pub-3857946786580406"
            data-ad-slot="7067398117"
            data-ad-format="auto"
            data-full-width-responsive="true"></ins>
      </div>
      <div class="row" style="margin:8px 0 12px 0; align-items:center;">
        <select id="lbMode">
          <option value="normal">Normal</option>
          <option value="daily">Daily (today)</option>
        </select>
        <div id="lbInfo" style="opacity:.8; font-size:13px;"></div>
      </div>
      <table id="lbTable"><thead><tr><th style="width:56px;">#</th><th>Name</th><th>Score</th><th style="text-align:right;">When</th></tr></thead><tbody></tbody></table>
    </div>
  </div>

  <!-- Quickbar + Daily Banner -->
  <div id="quickbar">
    <button id="restartBtn" class="cta cta--primary" style="padding:10px 14px;">↻ Restart</button>
    <button id="shareBtn" class="cta cta--secondary" style="padding:10px 14px;">📣 Share</button>
  </div>
  <div id="dailyBanner">Daily Challenge</div>

<script>
(() => {
  const $ = (sel) => document.querySelector(sel);
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W=0, H=0, DPR=Math.min(devicePixelRatio||1,2);

  /* ====== layout sizing (ad-aware) ====== */
  function resize(){
    const spacer = document.getElementById('ad-spacer');
    const adH = (spacer && spacer.offsetHeight) || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--adH')) || 0;
    W = innerWidth|0;
    H = Math.max(0, (innerHeight|0) - adH);
    canvas.width  = Math.max(1, W*DPR);
    canvas.height = Math.max(1, H*DPR);
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize);

  const topIns = document.getElementById('ad-top-unit');
  function tryFillTopAd(){
    if(!topIns) return;
    const w = topIns.clientWidth;
    if(w && w > 0){ (window.adsbygoogle=window.adsbygoogle||[]).push({}); return true; }
    return false;
  }
  window.addEventListener('load', ()=>{
    let ok = tryFillTopAd();
    if(!ok){ const id = setInterval(()=>{ if(tryFillTopAd()) clearInterval(id); }, 200); setTimeout(()=> clearInterval(id), 5000); }
    resize();
  });

  const spacer = document.getElementById('ad-spacer');
  const topWrap = document.getElementById('ad-top-wrapper');
  function updateAdVars(){
    const h = (topWrap && topWrap.offsetHeight) || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--adCap')) || 0;
    spacer.style.height = h + 'px';
    document.documentElement.style.setProperty('--adH', h+'px');
    resize();
  }
  if('ResizeObserver' in window && topWrap){ new ResizeObserver(updateAdVars).observe(topWrap); } else { setTimeout(updateAdVars, 300); }

  /* ====== storage helpers ====== */
  function getLS(k, fallback){ try{ const v = localStorage.getItem('dev_' + k); return v===null? fallback: v; }catch{ return fallback; } }
  function setLS(k, v){ try{ localStorage.setItem('dev_' + k, v); }catch{} }

  /* ====== state ====== */
  const state={ 
    running:false, paused:false, score:0, combo:0, time:0,
    best:Number(getLS('lr_best', 0)), dailyBest:Number(getLS('lr_daily', 0)),
    spawnTimer:0, spawnInterval:1.1, dailyMode:false,
    // DEV MODE FLAGS
    devMode: true,
    showDebugInfo: true
  };

  /* ====== UI refs ====== */
  const ui={
    score:$('#score'), combo:$('#combo'), best:$('#best'), daily:$('#daily'),
    overlay:$('#overlay'),
    ovTitle:$('#overlayTitle'), ovBody:$('#overlayBody'),
    start:$('#start'), dailyBtn:$('#dailyBtn'),
    btnResume:$('#btnResume'), btnPlayAgain:$('#btnPlayAgain'), btnShare:$('#btnShare'),
    lbBtn:$('#lbBtn'), nameInput:$('#nameInput'),
    restartBtn:$('#restartBtn'), shareBtn:$('#shareBtn'),
    dailyBanner:$('#dailyBanner')
  };

  function hydrateHUD(){ ui.score.textContent='Score: 0'; ui.combo.textContent='Combo: 0'; ui.best.textContent='Best: '+state.best; ui.daily.textContent='Daily: '+state.dailyBest; }
  hydrateHUD();
  ui.dailyBanner.textContent = 'DEV Daily: ' + new Date().toISOString().slice(0,10);

  /* ====== Pause/Resume helpers (overlay driven) ====== */
  function showOverlay(){ ui.overlay.classList.add('visible'); }
  function hideOverlay(){ ui.overlay.classList.remove('visible'); }

  function setOverlayHome(){
    ui.ovTitle.textContent = 'Loop Runner DEV';
    ui.ovBody.innerHTML = '🚧 Development Version - Testing new features! 🚧<br><br>Dash through enemies. Click/tap to dash toward the pointer. Chain kills to build combo. Don\'t touch enemies while not dashing.';
    ui.btnResume.style.display = 'none';
    ui.btnPlayAgain.style.display = 'none';
    showOverlay();
  }
  function setOverlayPaused(){
    ui.ovTitle.textContent = 'Paused';
    ui.ovBody.innerHTML = 'Press <b>P</b> or <b>Esc</b> to resume';
    ui.btnResume.style.display = '';
    ui.btnPlayAgain.style.display = '';
    showOverlay();
  }
  function setOverlayGameOver(score, best, isPB){
    ui.ovTitle.textContent = isPB ? 'New Best!' : 'Game Over';
    ui.ovBody.innerHTML = `Score: <b>${score}</b> • Best: <b>${best}</b>${isPB?' • 🎉':''}`;
    ui.btnResume.style.display = 'none';
    ui.btnPlayAgain.style.display = '';
    showOverlay();
  }

  /* ====== RNG ====== */
  const todayKey=()=>new Date().toISOString().slice(0,10);
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}};
  let seededRand=Math.random; let usingSeed=false;
  function setDailySeed(){ usingSeed=true; seededRand=mulberry32(hashToInt('looprunner:'+todayKey())); }
  function rnd(a=0,b=1){ return (usingSeed?seededRand():Math.random())*(b-a)+a; }
  function rndi(a,b){ return Math.floor(rnd(a,b+1)); }
  function hashToInt(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619); } return h>>>0; }

  /* ====== Audio ====== */
  let audio, master;
  function initAudio(){ 
    if(!audio){ 
      audio=new (window.AudioContext||window.webkitAudioContext)(); 
      master=audio.createGain(); 
      master.gain.value=0.08; 
      master.connect(audio.destination); 
    } 
  }
  
  // Enhanced Audio System
  const audioSettings = { enabled: true, volume: 0.3 };
  
  function playTone(freq, duration, type='sine', volume=1) {
    if (!audio || !audioSettings.enabled) return;
    const osc = audio.createOscillator();
    const gain = audio.createGain();
    osc.connect(gain);
    gain.connect(master);
    osc.frequency.value = freq;
    osc.type = type;
    gain.gain.value = volume * audioSettings.volume;
    gain.gain.exponentialRampToValueAtTime(0.01, audio.currentTime + duration);
    osc.start();
    osc.stop(audio.currentTime + duration);
  }
  
  function playDashSound() { playTone(440, 0.1, 'square', 0.3); }
  function playKillSound(combo) { 
    const freq = 220 + (combo * 50);
    playTone(freq, 0.15, 'sawtooth', 0.4); 
  }
  function playComboSound(combo) {
    for(let i = 0; i < Math.min(combo, 5); i++) {
      setTimeout(() => playTone(440 + i * 110, 0.1, 'sine', 0.2), i * 50);
    }
  }
  function playGameOverSound() { playTone(110, 0.5, 'triangle', 0.5); }

  /* ====== Entities ====== */
  const player={ x:W/2, y:H/2, r:12, vx:0, vy:0, maxSpeed:900, friction:9, dashing:false, dashCooldown:0, dashWindup:0 };
  const enemies=[]; const particles=[]; const powerups=[];
  
  // Visual effects system
  let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
  let comboDisplay = { scale: 1, alpha: 1, text: '', timer: 0 };
  let dashTrail = [];
  
  // Power-up types
  const POWERUP_TYPES = {
    SHIELD: { color: '#88ccff', duration: 3, icon: '🛡️' },
    SPEED: { color: '#ffcc88', duration: 2, icon: '⚡' },
    MULTIDASH: { color: '#cc88ff', duration: 4, icon: '💫' },
    SLOWMO: { color: '#ff88cc', duration: 2, icon: '⏰' }
  };
  
  // Player power-up state
  const playerPowers = {
    shield: 0,
    speed: 0,
    multidash: 0,
    slowmo: 0
  };
  
  // Enemy types
  const ENEMY_TYPES = {
    NORMAL: { color: 'speed', size: 1, speed: 1, points: 10 },
    FAST: { color: '#ff6666', size: 0.8, speed: 1.5, points: 20 },
    BIG: { color: '#6666ff', size: 1.4, speed: 0.7, points: 30 },
    BONUS: { color: '#ffff66', size: 1.2, speed: 1.2, points: 50 }
  };

  function addParticle(x,y,size=2,life=0.4,color='#8fb3ff'){ 
    const a=rnd(0,Math.PI*2); 
    const sp=rnd(40,240); 
    particles.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life, maxLife:life, size, color}); 
  }
  
  function addComboParticles(x, y, combo) {
    const colors = ['#88ffcc', '#ffcc88', '#ff88cc', '#cc88ff', '#88ccff'];
    const color = colors[Math.min(combo - 1, colors.length - 1)];
    for(let i = 0; i < Math.min(combo * 3, 20); i++) {
      addParticle(x, y, rnd(2, 5), rnd(0.3, 0.8), color);
    }
  }
  
  function addDashParticles(x, y) {
    for(let i = 0; i < 15; i++) {
      addParticle(x, y, rnd(1, 3), rnd(0.2, 0.4), '#88ffcc');
    }
  }
  
  function addScreenShake(intensity, duration) {
    screenShake.intensity = Math.max(screenShake.intensity, intensity);
    screenShake.duration = Math.max(screenShake.duration, duration);
  }
  
  function updateComboDisplay(combo) {
    comboDisplay.scale = 1.5;
    comboDisplay.alpha = 1;
    comboDisplay.text = `x${combo} COMBO!`;
    comboDisplay.timer = 1.0;
  }
  
  function addDashTrail(x, y) {
    dashTrail.push({ x, y, life: 0.3, maxLife: 0.3 });
    if(dashTrail.length > 10) dashTrail.shift();
  }
  
  function spawnPowerup() {
    if(powerups.length >= 2) return; // Max 2 powerups on screen
    const types = Object.keys(POWERUP_TYPES);
    const type = types[rndi(0, types.length - 1)];
    const x = rnd(50, W - 50);
    const y = rnd(50, H - 50);
    powerups.push({ x, y, type, life: 10, maxLife: 10, collected: false });
  }
  
  function spawnEnemy(){ 
    const m=24; 
    const side=rndi(0,3); 
    let x,y; 
    if(side===0){x=rnd(-m,W+m); y=-m;} 
    else if(side===1){x=W+m; y=rnd(-m,H+m);} 
    else if(side===2){x=rnd(-m,W+m); y=H+m;} 
    else {x=-m; y=rnd(-m,H+m);} 
    
    // Determine enemy type based on score
    let enemyType = 'NORMAL';
    const rand = rnd(0, 100);
    if(state.score > 500) {
      if(rand < 10) enemyType = 'BONUS';
      else if(rand < 30) enemyType = 'BIG';
      else if(rand < 60) enemyType = 'FAST';
    } else if(state.score > 200) {
      if(rand < 20) enemyType = 'FAST';
      else if(rand < 35) enemyType = 'BIG';
    }
    
    const type = ENEMY_TYPES[enemyType];
    const r = rnd(14, 22) * type.size;
    const baseSpeed = rnd(40, 90) + Math.min(state.time * 4, 220);
    const speed = baseSpeed * type.speed;
    const ang = Math.atan2(player.y - y, player.x - x) + rnd(-0.5, 0.5);
    const vx = Math.cos(ang) * speed;
    const vy = Math.sin(ang) * speed;
    
    enemies.push({x, y, r, vx, vy, speed, ang, type: enemyType, points: type.points});
  }

  /* ====== Input ====== */
  let pointer={ x:W/2, y:H/2, down:false };
  function screenToWorld(e){ const rect=canvas.getBoundingClientRect(); return { x:(e.clientX-rect.left), y:(e.clientY-rect.top) }; }
  function startDashTowards(px,py){ 
    if(player.dashCooldown>0) return; 
    
    // Multi-dash power-up allows multiple dashes
    const dashCount = playerPowers.multidash > 0 ? 3 : 1;
    
    for(let i = 0; i < dashCount; i++) {
      setTimeout(() => {
        if(i === 0) {
          const dx=px-player.x, dy=py-player.y; 
          const len=Math.hypot(dx,dy)||1; 
          const ux=dx/len, uy=dy/len;
          const speedMultiplier = playerPowers.speed > 0 ? 1.5 : 1;
          player.vx=ux*player.maxSpeed*speedMultiplier; 
          player.vy=uy*player.maxSpeed*speedMultiplier; 
          player.dashing=true; 
          player.dashCooldown=0.35; 
          player.dashWindup=0.12; 
          addDashParticles(player.x, player.y);
          addScreenShake(2, 0.1);
          playDashSound();
        } else {
          // Additional dashes for multi-dash
          const angle = (Math.PI * 2 / dashCount) * i;
          const dx = Math.cos(angle) * 100;
          const dy = Math.sin(angle) * 100;
          addDashParticles(player.x + dx, player.y + dy);
        }
      }, i * 100);
    }
  }
  
  // Original single dash logic (keeping for compatibility)
  function startDashTowardsOrig(px,py){ 
    if(player.dashCooldown>0) return; 
    const dx=px-player.x, dy=py-player.y; 
    const len=Math.hypot(dx,dy)||1; 
    const ux=dx/len, uy=dy/len; 
    const speedMultiplier = playerPowers.speed > 0 ? 1.5 : 1;
    player.vx=ux*player.maxSpeed*speedMultiplier; 
    player.vy=uy*player.maxSpeed*speedMultiplier; 
    player.dashing=true; 
    player.dashCooldown=0.35; 
    player.dashWindup=0.12; 
    addDashParticles(player.x, player.y);
    addScreenShake(2, 0.1);
    playDashSound();
  }
  canvas.addEventListener('pointerdown',(e)=>{ initAudio(); const p=screenToWorld(e); pointer.down=true; pointer.x=p.x; pointer.y=p.y; startDashTowardsOrig(pointer.x,pointer.y); });
  canvas.addEventListener('pointermove',(e)=>{ const p=screenToWorld(e); pointer.x=p.x; pointer.y=p.y; });
  canvas.addEventListener('pointerup',()=>{ pointer.down=false; });

  addEventListener('keydown',(e)=>{
    if(e.repeat) return;
    if(e.code==='Space'){ if(!state.running){ e.preventDefault(); startGame(state.dailyMode); return; } }
    if(e.key==='r' || e.key==='R'){ e.preventDefault(); startGame(state.dailyMode); return; }
    if(e.key==='p' || e.key==='P' || e.key==='Escape'){ e.preventDefault(); if(state.running){ if(!state.paused) pauseGameUI(); else resumeGameUI(); } return; }
    const amt=80; if(e.key&&e.key.indexOf('Arrow')===0){ let dx=0, dy=0; if(e.key==='ArrowUp') dy=-amt; else if(e.key==='ArrowDown') dy=amt; else if(e.key==='ArrowLeft') dx=-amt; else if(e.key==='ArrowRight') dx=amt; startDashTowardsOrig(player.x+dx, player.y+dy);} 
    
    // Audio controls
    if(e.key==='m' || e.key==='M'){ audioSettings.enabled = !audioSettings.enabled; console.log('Audio:', audioSettings.enabled ? 'ON' : 'OFF'); }
  });
  addEventListener('blur', ()=>{ if(state.running && !state.paused) pauseGameUI(); });

  /* ====== Leaderboard ====== */
  const lb={ modal:$('#lbModal'), close:$('#lbClose'), modeSel:$('#lbMode'), info:$('#lbInfo'), table:$('#lbTable').querySelector('tbody') };
  function loadLB(key){ try{ return JSON.parse(getLS(key,'[]')); }catch{ return []; } }
  function saveLB(key,arr){ setLS(key, JSON.stringify(arr)); }

  const SB_URL = 'https://zpoerliqhcywaulbthyf.supabase.co/rest/v1/scores';
  const SB_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpwb2VybGlxaGN5d2F1bGJ0aHlmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgyMDQxNjYsImV4cCI6MjA3Mzc4MDE2Nn0.7jjITj1H2AxWPnCeyzmMsNw3uAVACoYb_CV5rRoD65k';
  const SB_HEADERS = { 'apikey': SB_KEY, 'Authorization': 'Bearer '+SB_KEY, 'Content-Type': 'application/json' };

  function showLeaderboard(mode){ lb.modal.classList.add('show'); lb.modeSel.value = mode || (state.dailyMode?'daily':'normal'); renderLeaderboard(); maybeFillModalAd(); }
  function hideLeaderboard(){ lb.modal.classList.remove('show'); }

  function renderLeaderboard(){
    const mode = lb.modeSel.value;
    
    // DEV MODE: Always use local scores first
    lb.table.innerHTML = '';
    
    const key = mode==='daily' ? ('lr_lb_daily_'+todayKey()) : 'lr_lb_normal';
    const arr = loadLB(key);
    lb.info.textContent = 'Development Leaderboard (Local Scores)';
    
    arr.slice(0,10).forEach((e,i) => {
      const tr = document.createElement('tr');
      const when = e.when ? new Date(e.when).toLocaleString() : 'Unknown';
      tr.innerHTML = `<td>${i+1}</td><td>${escapeHtml(e.name)}</td><td>${e.score}</td><td style="text-align:right;opacity:.8">${when}</td>`;
      lb.table.appendChild(tr);
    });
    
    if (arr.length===0){
      const tr=document.createElement('tr');
      tr.innerHTML='<td colspan="4" style="opacity:.7;">No dev scores yet. Play a game to see your scores here!</td>';
      lb.table.appendChild(tr);
    }
  }
  function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c])); }
  lb.close.addEventListener('click', hideLeaderboard);
  lb.modeSel.addEventListener('change', renderLeaderboard);
  ui.lbBtn.addEventListener('click', ()=> showLeaderboard());

  let modalAdFilled = false;
  function maybeFillModalAd(){
    if(modalAdFilled) return;
    const ins = document.getElementById('ad-modal-unit');
    if(!ins) return;
    const w = ins.clientWidth;
    if(w && w>0){ (window.adsbygoogle=window.adsbygoogle||[]).push({}); modalAdFilled = true; }
    else { setTimeout(maybeFillModalAd, 200); }
  }

  /* ====== Share (overlay + quickbar) ====== */
  async function doShare(){
    const url = location.href;
    const text = `I just played Loop Runner and scored ${state.score|0}!`;
    try{
      if (navigator.share){ await navigator.share({ title:'Loop Runner', text, url }); }
      else {
        await navigator.clipboard.writeText(url);
        alert('Link copied to clipboard!');
      }
    }catch(e){ /* user cancelled */ }
  }

  /* ====== Game control ====== */
  function startGame(daily=false){
    state.running=true; state.paused=false; state.time=0; state.score=0; state.combo=0; state.spawnTimer=0; state.spawnInterval=1.1; 
    enemies.length=0; particles.length=0; powerups.length=0; dashTrail.length=0;
    player.x=W/2; player.y=H/2; player.vx=0; player.vy=0; player.dashing=false; player.dashCooldown=0; player.dashWindup=0; 
    // Reset power-ups
    Object.keys(playerPowers).forEach(key => playerPowers[key] = 0);
    hydrateHUD(); state.dailyMode=daily; usingSeed=false; if(daily) setDailySeed(); hideOverlay();
  }
  function gameOver(){
    state.running=false; state.paused=false;
    const score = state.score|0;
    let isPB = false;
    if(state.dailyMode){ if(score > state.dailyBest){ state.dailyBest = score; setLS('lr_daily', state.dailyBest); isPB = true; } }
    else { if(score > state.best){ state.best = score; setLS('lr_best', state.best); isPB = true; } }
    hydrateHUD();
    setOverlayGameOver(score, state.dailyMode?state.dailyBest:state.best, isPB);
    submitScore();
    playGameOverSound();
    showLeaderboard(state.dailyMode?'daily':'normal');
    if (isPB) setTimeout(()=>{ try{ doShare(); }catch{} }, 450);
  }

  function pauseGameUI(){ if (!state.running || state.paused) return; state.paused = true; setOverlayPaused(); }
  function resumeGameUI(){ if (!state.paused) return; state.paused = false; hideOverlay(); }

  async function submitScore(){
    const name=(ui.nameInput.value||getLS('lr_name','DevPlayer')).slice(0,20).trim()||'DevPlayer';
    setLS('lr_name',name);
    
    // In dev mode, don't submit to live leaderboard
    console.log('DEV MODE: Would submit score:', { name, score: state.score|0, mode: state.dailyMode ? 'daily' : 'normal' });
    // DEV MODE: Still save locally for offline leaderboard testing
    // DEV MODE: Still save locally for offline leaderboard testing
    const key = state.dailyMode ? ('lr_lb_daily_'+todayKey()) : 'lr_lb_normal';
    const arr = loadLB(key);
    const entry = { name, score: state.score|0, when: new Date().toISOString() };
    arr.push(entry);
    arr.sort((a,b) => b.score - a.score);
    if(arr.length > 50) arr.length = 50;
    saveLB(key, arr);
    saveLB(key, arr);
  }

  ui.start.addEventListener('click', ()=>{ initAudio(); startGame(false); });
  ui.dailyBtn.addEventListener('click', ()=>{ initAudio(); startGame(true); });
  ui.btnResume.addEventListener('click', resumeGameUI);
  ui.btnPlayAgain.addEventListener('click', ()=> startGame(state.dailyMode));
  ui.btnShare.addEventListener('click', doShare);
  ui.restartBtn.addEventListener('click', ()=> startGame(state.dailyMode));
  ui.shareBtn.addEventListener('click', doShare);

  /* ====== Loop ====== */
  let last = performance.now();
  let powerupSpawnTimer = 0;
  
  function loop(){
    requestAnimationFrame(loop);
    const t=performance.now(); let dt=(t-last)/1000; last=t;
    
    // Apply slow-motion effect
    if(playerPowers.slowmo > 0) dt *= 0.5;
    
    if(!state.running || state.paused){ render(); return; }
    state.time += dt; state.score += dt*10; if(((state.score|0)%10)===0) ui.score.textContent=`Score: ${state.score|0}`;
    update(dt); render();
  }

  function update(dt){
    // Update power-up timers
    Object.keys(playerPowers).forEach(key => {
      if(playerPowers[key] > 0) {
        playerPowers[key] -= dt;
        if(playerPowers[key] <= 0) playerPowers[key] = 0;
      }
    });
    
    // Spawn power-ups occasionally
    powerupSpawnTimer -= dt;
    if(powerupSpawnTimer <= 0 && state.score > 100) {
      if(rnd(0, 100) < 15) spawnPowerup(); // 15% chance
      powerupSpawnTimer = rnd(3, 8); // Reset timer
    }
    
    state.spawnTimer-=dt; if(state.spawnTimer<=0){ spawnEnemy(); state.spawnTimer=state.spawnInterval; }
    if(player.dashWindup>0){ player.dashWindup-=dt; if(player.dashWindup<=0) player.dashing=false; }
    
    // Update visual effects
    if(screenShake.duration > 0) {
      screenShake.duration -= dt;
      screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
      screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
      if(screenShake.duration <= 0) {
        screenShake.x = screenShake.y = screenShake.intensity = 0;
      }
    }
    
    if(comboDisplay.timer > 0) {
      comboDisplay.timer -= dt;
      comboDisplay.scale = lerp(comboDisplay.scale, 1, dt * 3);
      comboDisplay.alpha = comboDisplay.timer / 1.0;
    }
    
    // Update dash trail
    if(player.dashing) {
      addDashTrail(player.x, player.y);
    }
    for(let i = 0; i < dashTrail.length; i++) {
      dashTrail[i].life -= dt;
      if(dashTrail[i].life <= 0) {
        dashTrail.splice(i, 1);
        i--;
      }
    }
    
    const f=Math.exp(-player.friction*dt); player.vx*=f; player.vy*=f; player.x+=player.vx*dt; player.y+=player.vy*dt; player.x=Math.max(8,Math.min(W-8,player.x)); player.y=Math.max(8,Math.min(H-8,player.y)); if(player.dashCooldown>0) player.dashCooldown-=dt;
    
    // Check power-up collection
    for(let i = 0; i < powerups.length; i++) {
      const p = powerups[i];
      p.life -= dt;
      const d = Math.hypot(p.x - player.x, p.y - player.y);
      if(d < 25) {
        // Collect power-up
        playerPowers[p.type.toLowerCase()] = POWERUP_TYPES[p.type].duration;
        addParticle(p.x, p.y, 4, 0.8, POWERUP_TYPES[p.type].color);
        powerups.splice(i, 1);
        i--;
        playComboSound(2);
      } else if(p.life <= 0) {
        powerups.splice(i, 1);
        i--;
      }
    }
    
    for(let i=0;i<enemies.length;i++){
      const e=enemies[i];
      const ang=Math.atan2(player.y-e.y, player.x-e.x); e.vx=Math.cos(ang)*e.speed; e.vy=Math.sin(ang)*e.speed; e.ang = Math.atan2(e.vy, e.vx); e.x+=e.vx*dt; e.y+=e.vy*dt;
      const d=Math.hypot(e.x-player.x, e.y-player.y);
      if(d<e.r+player.r){
        if(player.dashing || playerPowers.shield > 0){ 
          enemies.splice(i,1); i--; 
          state.combo+=1; 
          const basePoints = e.points || 10;
          const add = Math.floor(basePoints * Math.pow(1.4, state.combo-1)); 
          state.score += add; 
          ui.combo.textContent=`Combo: ${state.combo}`; 
          ui.score.textContent=`Score: ${state.score|0}`;
          
          // Enhanced visual feedback for kills
          addComboParticles(e.x, e.y, state.combo);
          addScreenShake(Math.min(state.combo * 0.5, 8), 0.15);
          updateComboDisplay(state.combo);
          playKillSound(state.combo);
          
          // Trigger slow-mo on high combos
          if(state.combo >= 5 && state.combo % 5 === 0) {
            playerPowers.slowmo = Math.max(playerPowers.slowmo, 1.5);
          }
        }
        else if(playerPowers.shield <= 0) { 
          gameOver(); break; 
        }
      }
      if(e.x<-100||e.x>W+100||e.y<-100||e.y>H+100){ enemies.splice(i,1); i--; }
    }
    for(let i=0;i<particles.length;i++){ const p=particles[i]; p.life-=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vx*=0.98; p.vy*=0.98; if(p.life<=0){ particles.splice(i,1); i--; } }
  }

  /* ====== Visuals ====== */
  function clamp01(t){ return Math.max(0, Math.min(1, t)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpColor(c1, c2, t){
    return [
      Math.round(lerp(c1[0], c2[0], t)),
      Math.round(lerp(c1[1], c2[1], t)),
      Math.round(lerp(c1[2], c2[2], t))
    ];
  }
  const COL_BLUE=[88,166,255], COL_YELLOW=[255,210,119], COL_RED=[255,95,95];
  function speedToColor(speed){
    const t = clamp01((speed-40)/270);
    if(t<0.5){
      const u=t/0.5; const c=lerpColor(COL_BLUE, COL_YELLOW, u);
      return `rgb(${c[0]},${c[1]},${c[2]})`;
    } else {
      const u=(t-0.5)/0.5; const c=lerpColor(COL_YELLOW, COL_RED, u);
      return `rgb(${c[0]},${c[1]},${c[2]})`;
    }
  }
  
  function drawDot(e){
    let fill;
    if(e.type && ENEMY_TYPES[e.type] && ENEMY_TYPES[e.type].color !== 'speed') {
      fill = ENEMY_TYPES[e.type].color;
    } else {
      fill = speedToColor(e.speed);
    }
    
    ctx.save();
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
    ctx.fillStyle = fill;
    ctx.shadowColor = fill;
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
    ctx.stroke();
    
    // Draw type indicator for special enemies
    if(e.type && e.type !== 'NORMAL') {
      ctx.fillStyle = '#fff';
      ctx.font = `${e.r * 0.8}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const symbols = { FAST: '⚡', BIG: '●', BONUS: '★' };
      ctx.fillText(symbols[e.type] || '?', e.x, e.y);
    }
    
    ctx.restore();
  }
  
  function render(){
    ctx.save();
    
    // Apply screen shake
    ctx.translate(screenShake.x, screenShake.y);
    
    ctx.clearRect(0,0,W,H);
    
    // DEV MODE: Draw debug grid
    if(state.showDebugInfo){
      ctx.strokeStyle = 'rgba(255, 107, 107, 0.1)';
      ctx.lineWidth = 1;
      for(let x = 0; x < W; x += 50){
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for(let y = 0; y < H; y += 50){
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }
    }
    
    // Draw dash trail
    for(const trail of dashTrail) {
      const alpha = trail.life / trail.maxLife;
      ctx.save();
      ctx.globalAlpha = alpha * 0.6;
      ctx.beginPath();
      ctx.arc(trail.x, trail.y, 8, 0, Math.PI * 2);
      ctx.fillStyle = '#88ffcc';
      ctx.fill();
      ctx.restore();
    }
    
    for(const p of particles){
      const a=Math.max(0, Math.min(1, p.life/p.maxLife));
      ctx.globalAlpha=a;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
      ctx.fillStyle=p.color || '#8fb3ff';
      ctx.fill();
      ctx.globalAlpha=1;
    }
    
    for(const e of enemies){ drawDot(e); }
    
    // Draw power-ups
    for(const p of powerups) {
      const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
      ctx.save();
      ctx.globalAlpha = pulse;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 15, 0, Math.PI * 2);
      ctx.fillStyle = POWERUP_TYPES[p.type].color;
      ctx.shadowColor = POWERUP_TYPES[p.type].color;
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw icon
      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(POWERUP_TYPES[p.type].icon, p.x, p.y);
      ctx.restore();
    }
    
    // Enhanced player rendering
    ctx.beginPath();
    ctx.arc(player.x,player.y,player.r,0,Math.PI*2);
    
    // Player color based on power-ups
    let playerColor = '#e6edf3';
    if(playerPowers.shield > 0) playerColor = '#88ccff';
    else if(playerPowers.speed > 0) playerColor = '#ffcc88';
    else if(playerPowers.multidash > 0) playerColor = '#cc88ff';
    else if(player.dashing) playerColor = '#88ffcc';
    
    ctx.fillStyle = playerColor;
    ctx.shadowColor = playerColor;
    ctx.shadowBlur = (player.dashing || Object.values(playerPowers).some(p => p > 0)) ? 12 : 0;
    ctx.fill();
    
    // Draw dash cooldown indicator
    if(player.dashCooldown > 0) {
      const cooldownPercent = player.dashCooldown / 0.35;
      ctx.save();
      ctx.strokeStyle = '#ff6b6b';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r + 4, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * (1 - cooldownPercent)));
      ctx.stroke();
      ctx.restore();
    }
    
    // Draw combo display
    if(comboDisplay.timer > 0) {
      ctx.save();
      ctx.globalAlpha = comboDisplay.alpha;
      ctx.font = `bold ${16 * comboDisplay.scale}px system-ui`;
      ctx.fillStyle = '#ffcc88';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeText(comboDisplay.text, W/2, H/2 - 60);
      ctx.fillText(comboDisplay.text, W/2, H/2 - 60);
      ctx.restore();
    }
    
    // Draw power-up status
    let yOffset = 20;
    Object.keys(playerPowers).forEach(power => {
      if(playerPowers[power] > 0) {
        ctx.fillStyle = '#fff';
        ctx.font = '14px Arial';
        ctx.fillText(`${power.toUpperCase()}: ${playerPowers[power].toFixed(1)}s`, W - 150, yOffset);
        yOffset += 20;
      }
    });
    
    // DEV MODE: Show debug info
    if(state.showDebugInfo && state.running){
      ctx.fillStyle = '#ff6b6b';
      ctx.font = '12px monospace';
      ctx.fillText(`DEV: Enemies: ${enemies.length}`, 10, H - 60);
      ctx.fillText(`DEV: Particles: ${particles.length}`, 10, H - 45);
      ctx.fillText(`DEV: Time: ${state.time.toFixed(1)}s`, 10, H - 30);
      ctx.fillText(`DEV: Spawn Timer: ${state.spawnTimer.toFixed(2)}`, 10, H - 15);
      ctx.fillText(`DEV: Dash Trail: ${dashTrail.length}`, 10, H - 75);
      ctx.fillText(`DEV: Screen Shake: ${screenShake.intensity.toFixed(1)}`, 10, H - 90);
      ctx.fillText(`DEV: Powerups: ${powerups.length}`, 10, H - 105);
      ctx.fillText(`DEV: Audio: ${audioSettings.enabled ? 'ON' : 'OFF'} (M to toggle)`, 10, H - 120);
    }
    
    ctx.restore();
  }

  /* ====== Modal close-click ====== */
  document.getElementById('lbModal').addEventListener('click', (e)=>{ if(e.target.id==='lbModal') e.currentTarget.classList.remove('show'); });

  /* ====== Boot ====== */
  resize();
  requestAnimationFrame(function loopStart(){ requestAnimationFrame(loop); });
  setOverlayHome();
  
  // DEV MODE: Add console info
  console.log('🚧 Loop Runner Development Mode Active 🚧');
  console.log('Features:');
  console.log('- Separate localStorage (dev_ prefix)');
  console.log('- Debug grid and info display');
  console.log('- Scores not submitted to live leaderboard');
  console.log('- Visual dev mode indicators');
  console.log('- Press M to toggle audio');
  console.log('- Power-ups spawn after score 100');
  console.log('- Enemy variety increases with score');
})();
</script>

<script>
  // No-scroll hardening for touch devices
  function preventScroll(e){ e.preventDefault(); }
  window.addEventListener('touchmove', preventScroll, { passive:false });
  window.addEventListener('wheel', preventScroll, { passive:false });
</script>
</body>
</html>
