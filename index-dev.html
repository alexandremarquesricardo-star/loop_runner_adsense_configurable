<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- SEO Meta -->
  <title>Loop Runner DEV â€” Development Version</title>
  <meta name="description" content="Development version of Loop Runner for testing new features." />
  <link rel="canonical" href="https://playloop.run/">
  <meta name="robots" content="index,follow,max-image-preview:large">
  <meta name="keywords" content="free browser game, action game, leaderboard game, reflex game, playloop, loop runner, instant play game">
  <meta name="theme-color" content="#0b0b10">

  <!-- Social / Open Graph -->
  <meta property="og:title" content="Loop Runner DEV â€” Development Version">
  <meta property="og:description" content="Dash, chain, and climb the leaderboard in Loop Runner. A lightning-fast browser game â€” free to play, no downloads.">
  <meta property="og:url" content="https://playloop.run/">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Playloop">
  <meta property="og:locale" content="en_GB">
  <meta property="og:image" content="https://playloop.run/looprunner-preview.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Loop Runner DEV â€” Development Version">
  <meta name="twitter:description" content="Dash, chain, and climb the leaderboard in Loop Runner. Free, fast-paced, and playable instantly in your browser.">
  <meta name="twitter:image" content="https://playloop.run/looprunner-preview.png">

  <!-- PWA / Icons -->
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="favicon.ico">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">

  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Loop Runner",
    "url": "https://playloop.run/",
    "image": "https://playloop.run/looprunner-preview.png",
    "description": "Dash, chain, and climb the leaderboard in Loop Runner â€” a free, fast-paced browser action game you can play instantly.",
    "inLanguage": "en",
    "applicationCategory": "Game",
    "operatingSystem": "Web",
    "gamePlatform": "Browser",
    "playMode": ["SinglePlayer"],
    "publisher": { "@type": "Organization", "name": "Playloop" },
    "offers": { "@type": "Offer", "price": "0", "priceCurrency": "GBP" }
  }
  </script>

  <!-- Consent Mode v2 (default denied) -->
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('consent','default',{
      'ad_storage':'denied','ad_user_data':'denied','ad_personalization':'denied','analytics_storage':'denied'
    });
  </script>

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3857946786580406" crossorigin="anonymous"></script>

  <!-- Funding Choices (CMP) -->
  <script async src="https://fundingchoicesmessages.google.com/i/pub-3857946786580406?ers=1"></script>
  <script>
    (function signalGooglefcPresent() {
      if (!window.frames['googlefcPresent']) {
        function add(){const f=document.createElement('iframe');f.style='width:0;height:0;border:0;display:none';f.name='googlefcPresent';document.body.appendChild(f);}
        document.body ? add() : setTimeout(signalGooglefcPresent,0);
      }
    })();
  </script>

  <style>
    /* ========= theme (from wireframe) ========= */
    :root{
      --bg:#0b0b10; --fg:#eaecef; --muted:#9aa0a6; --accent:#6cf; --card:rgba(20,20,28,.85);
      --adCap: 90px; /* cap the ad height */
      /* DEV MODE STYLING */
      --dev-border: 3px solid #ff6b6b;
      --dev-bg: rgba(255, 107, 107, 0.1);
    }
    @media (max-width: 991px){ :root{ --adCap: 60px; } }
    @media (max-width: 599px){ :root{ --adCap: 50px; } }

    *{ box-sizing:border-box }
    html, body { height:100%; margin:0; overflow:hidden; background:var(--bg); color:var(--fg); font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial; }

    /* DEV MODE INDICATOR */
    body::before {
      content: "ðŸš§ DEVELOPMENT VERSION ðŸš§";
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #ff6b6b;
      color: white;
      text-align: center;
      padding: 4px;
      font-weight: bold;
      font-size: 12px;
      z-index: 1000;
      letter-spacing: 1px;
    }

    /* ========= Top Ad (hard-capped) ========= */
    #ad-top-wrapper{ position:fixed; top:20px; left:0; right:0; z-index:30; background:rgba(0,0,0,.15); backdrop-filter:blur(3px); border-bottom:1px dashed #2a2f3a; display:flex; justify-content:center; padding:4px 8px 0; max-height:var(--adCap); overflow:hidden; }
    #ad-top-unit{ display:block !important; text-align:center; width:100% !important; height:var(--adCap) !important; line-height:0; }
    #ad-spacer{ height:calc(var(--adH, var(--adCap)) + 20px); }

    /* ========= Canvas ========= */
    canvas{ display:block; width:100vw; height:calc(100vh - var(--adH, var(--adCap))); image-rendering:crisp-edges; }

    /* ========= HUD ========= */
    #ui{ position:fixed; inset:0; pointer-events:none; }
    .hud{ position:absolute; left:12px; top:calc(var(--adH, var(--adCap)) + 32px); display:flex; gap:12px; align-items:center; }
    .pill{ background:#111826; border:1px solid #2e3240; padding:6px 10px; border-radius:999px; font-weight:600; letter-spacing:.3px; color:#c9d1d9; }

    /* ========= Overlay (wireframe style) ========= */
    #overlay{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; }
    #overlay.visible{ display:flex; }
<<<<<<< HEAD
<<<<<<< HEAD
    #overlayCard{ min-width:min(85%,520px); max-width:92%; border-radius:16px; padding:16px 18px; background:var(--card); box-shadow:0 10px 30px rgba(0,0,0,.35); outline:1px dashed #2e3240; border: var(--dev-border); }
=======
    #overlayCard{ min-width:min(85%,520px); max-width:92%; border-radius:16px; padding:16px 18px; background:var(--card); box-shadow:0 10px 30px rgba(0,0,0,.35); outline:1px dashed #2e3240; }
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
    #overlayTitle{ font-size:18px; margin:0 0 8px }
    #overlayBody{ opacity:.9; margin-bottom:10px }
    #overlayRow{ display:flex; gap:8px; flex-wrap:wrap }

    /* ========= Buttons ========= */
    .btn, .cta{ pointer-events:auto; border:0; border-radius:12px; padding:.6rem .9rem; background:#1a1a22; color:#fff; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.2); }
    .cta{ position:relative; border-radius:14px; font-weight:800; display:inline-flex; align-items:center; gap:10px; letter-spacing:.3px; user-select:none; -webkit-tap-highlight-color:transparent; }
    .cta--primary{ background:linear-gradient(135deg,#2c7cf7,#7cfdd6 120%); color:#06101a; border:1px solid rgba(124,253,214,.25); }
    .cta--secondary{ background:linear-gradient(135deg,#ff7ab6,#ffd277 120%); color:#1a0b0f; border:1px solid rgba(255,210,119,.25); }

    /* ========= Quickbar & Daily Banner ========= */
    #quickbar{ position:fixed; left:50%; transform:translateX(-50%); bottom:8px; display:flex; gap:8px; z-index:26; }
    #dailyBanner{ position:fixed; right:8px; bottom:8px; color:var(--muted); font-weight:600; z-index:26; background:#111826; border:1px solid #2e3240; padding:6px 10px; border-radius:10px; }

    /* ========= Modal (Leaderboard) ========= */
    .modal { pointer-events:auto; position: fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:28; }
    .modal.show { display:flex; }
    .sheet { width:min(560px, 92vw); background: rgba(0,0,0,0.6); backdrop-filter: blur(8px); border:1px solid rgba(255,255,255,0.1); border-radius:16px; padding:16px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
    .row { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
    table { width:100%; border-collapse: collapse; }
    th, td { text-align:left; padding:8px; border-bottom: 1px solid rgba(255,255,255,0.08); font-size:14px; }

    /* inputs */
    input[type="text"], select{ pointer-events:auto; background:#101823; border:1px solid #233146; color:#e6edf3; padding:10px 12px; border-radius:10px; outline:none; }
<<<<<<< HEAD
=======

    /* ========= Game Over Stats Grid ========= */
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin: 12px 0;
      font-size: 13px;
    }
    .stat-item {
      background: rgba(255,255,255,0.05);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .stat-label {
      opacity: 0.8;
      font-size: 11px;
      margin-bottom: 2px;
    }
    .stat-value {
      font-weight: bold;
      color: #6cf;
    }

    /* ========= Health Bar Styles ========= */
    .health-bar {
      position: absolute;
      width: 40px;
      height: 4px;
      background: rgba(0,0,0,0.5);
      border-radius: 2px;
      overflow: hidden;
    }
    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff4444, #ffaa44);
      transition: width 0.2s ease;
    }

    /* ========= Chain Dash Indicators ========= */
    .chain-indicator {
      position: absolute;
      pointer-events: none;
      color: #88ffcc;
      font-weight: bold;
      font-size: 12px;
      text-shadow: 0 0 4px rgba(136, 255, 204, 0.8);
    }
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
  </style>
</head>
<body>
  <!-- Top Ad (hard-capped) -->
  <div id="ad-top-wrapper">
    <ins id="ad-top-unit" class="adsbygoogle"
         style="display:block; text-align:center;"
         data-ad-client="ca-pub-3857946786580406"
         data-ad-slot="7067398117"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
  </div>
  <div id="ad-spacer"></div>

  <!-- Game Canvas -->
  <canvas id="game"></canvas>

  <!-- UI / HUD -->
  <div id="ui">
    <div class="hud">
      <div id="score" class="pill">Score: 0</div>
      <div id="combo" class="pill">Combo: 0</div>
      <div id="best" class="pill">Best: 0</div>
      <div id="daily" class="pill">Daily: 0</div>
<<<<<<< HEAD
=======
      <div id="controlMode" class="pill">Mouse: ON</div>
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
      <a href="privacy.html" class="pill" style="text-decoration:none; pointer-events:auto;">Privacy</a>
      <button id="lbBtn" class="cta cta--secondary" style="pointer-events:auto;">Leaderboard</button>
    </div>

    <!-- Overlay (wireframe look, driven by game state) -->
    <div id="overlay" class="visible" role="dialog" aria-modal="true">
      <div id="overlayCard">
        <h3 id="overlayTitle">Loop Runner DEV</h3>
<<<<<<< HEAD
        <div id="overlayBody">ðŸš§ Development Version - Testing new features! ðŸš§<br><br>Dash through enemies. Click/tap to dash toward the pointer. Chain kills to build combo. Don't touch enemies while not dashing.</div>
=======
        <div id="overlayBody">Dash through enemies. Click/tap to dash toward the pointer. Chain kills to build combo. Don't touch enemies while not dashing.</div>
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
        <div class="row" style="margin:8px 0;">
          <button id="start" class="cta cta--primary" aria-label="Play"><span aria-hidden="true">â–¶</span> Play</button>
          <button id="dailyBtn" class="cta cta--secondary" aria-label="Daily Run"><span aria-hidden="true">â˜€</span> Daily Run</button>
        </div>
        <div id="overlayRow" style="margin:8px 0 0 0;">
          <button class="btn" id="btnResume" style="display:none">â–¶ Resume</button>
          <button class="btn" id="btnPlayAgain" style="display:none">â†» Play Again</button>
          <button class="btn" id="btnShare">ðŸ“£ Share</button>
        </div>
<<<<<<< HEAD
        <div class="hint" style="opacity:.85; font-size:13px; margin-top:10px;">Controls: Click/Tap to dash â€¢ Space to restart â€¢ P / Esc to pause</div>
        <div style="margin-top:10px; opacity:.9; font-size:13px;">Name: <input id="nameInput" type="text" placeholder="Your name (for scores)" style="width:220px;" /></div>
=======
        <div class="hint" style="opacity:.85; font-size:13px; margin-top:10px;">
          <strong>NEW FEATURES:</strong><br>
          â€¢ <strong>Mouse Controls:</strong> Click to dash, Right-click for fire burst<br>
          â€¢ <strong>Fire Burst:</strong> F key or Right-click (10 projectiles)<br>
          â€¢ <strong>Chain Dash:</strong> Dash through multiple enemies<br>
          â€¢ <strong>Boss Enemies:</strong> Large enemies with health bars<br>
          â€¢ <strong>Toggle Controls:</strong> C key to switch mouse/keyboard
        </div>
        <div style="margin-top:10px; opacity:.9; font-size:13px;">Name: <input id="nameInput" type="text" placeholder="Your name (for scores)" style="width:220px;" /></div>
        <div id="gameStats" style="display:none;">
          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-label">Enemies Killed</div>
              <div class="stat-value" id="statEnemiesKilled">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Best Combo</div>
              <div class="stat-value" id="statBestCombo">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Bosses Killed</div>
              <div class="stat-value" id="statBossesKilled">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Total Dashes</div>
              <div class="stat-value" id="statTotalDashes">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Perfect Dashes</div>
              <div class="stat-value" id="statPerfectDashes">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Game Time</div>
              <div class="stat-value" id="statGameTime">0s</div>
            </div>
          </div>
        </div>
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
      </div>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="lbModal" class="modal">
    <div class="sheet">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h2>Leaderboard</h2>
        <button id="lbClose" class="cta cta--secondary" style="padding:10px 14px;">Close</button>
      </div>
      <div style="margin: 8px 0;">
        <ins id="ad-modal-unit" class="adsbygoogle"
            style="display:block; text-align:center;"
            data-ad-client="ca-pub-3857946786580406"
            data-ad-slot="7067398117"
            data-ad-format="auto"
            data-full-width-responsive="true"></ins>
      </div>
      <div class="row" style="margin:8px 0 12px 0; align-items:center;">
        <select id="lbMode">
          <option value="normal">Normal</option>
          <option value="daily">Daily (today)</option>
        </select>
        <div id="lbInfo" style="opacity:.8; font-size:13px;"></div>
      </div>
      <table id="lbTable"><thead><tr><th style="width:56px;">#</th><th>Name</th><th>Score</th><th style="text-align:right;">When</th></tr></thead><tbody></tbody></table>
    </div>
  </div>

  <!-- Quickbar + Daily Banner -->
  <div id="quickbar">
    <button id="restartBtn" class="cta cta--primary" style="padding:10px 14px;">â†» Restart</button>
    <button id="shareBtn" class="cta cta--secondary" style="padding:10px 14px;">ðŸ“£ Share</button>
  </div>
  <div id="dailyBanner">Daily Challenge</div>

<script>
(() => {
  const $ = (sel) => document.querySelector(sel);
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W=0, H=0, DPR=Math.min(devicePixelRatio||1,2);

<<<<<<< HEAD
=======
  // ---- Depth handoff config ----
  const DEPTH_URL = '/looprunner350.html'; // project root
  let depthKick = false; // session guard

>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
  /* ====== layout sizing (ad-aware) ====== */
  function resize(){
    const spacer = document.getElementById('ad-spacer');
    const adH = (spacer && spacer.offsetHeight) || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--adH')) || 0;
    W = innerWidth|0;
    H = Math.max(0, (innerHeight|0) - adH);
    canvas.width  = Math.max(1, W*DPR);
    canvas.height = Math.max(1, H*DPR);
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize);

  const topIns = document.getElementById('ad-top-unit');
  function tryFillTopAd(){
    if(!topIns) return;
    const w = topIns.clientWidth;
    if(w && w > 0){ (window.adsbygoogle=window.adsbygoogle||[]).push({}); return true; }
    return false;
  }
  window.addEventListener('load', ()=>{
    let ok = tryFillTopAd();
    if(!ok){ const id = setInterval(()=>{ if(tryFillTopAd()) clearInterval(id); }, 200); setTimeout(()=> clearInterval(id), 5000); }
    resize();
  });

  const spacer = document.getElementById('ad-spacer');
  const topWrap = document.getElementById('ad-top-wrapper');
  function updateAdVars(){
    const h = (topWrap && topWrap.offsetHeight) || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--adCap')) || 0;
    spacer.style.height = h + 'px';
    document.documentElement.style.setProperty('--adH', h+'px');
    resize();
  }
  if('ResizeObserver' in window && topWrap){ new ResizeObserver(updateAdVars).observe(topWrap); } else { setTimeout(updateAdVars, 300); }

  /* ====== storage helpers ====== */
<<<<<<< HEAD
  function getLS(k, fallback){ try{ const v = localStorage.getItem('dev_' + k); return v===null? fallback: v; }catch{ return fallback; } }
  function setLS(k, v){ try{ localStorage.setItem('dev_' + k, v); }catch{} }
=======
  function getLS(k, fallback){ try{ const v = localStorage.getItem(k); return v===null? fallback: v; }catch{ return fallback; } }
  function setLS(k, v){ try{ localStorage.setItem(k, v); }catch{} }
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e

  /* ====== state ====== */
  const state={ 
    running:false, paused:false, score:0, combo:0, time:0,
    best:Number(getLS('lr_best', 0)), dailyBest:Number(getLS('lr_daily', 0)),
    spawnTimer:0, spawnInterval:1.1, dailyMode:false,
<<<<<<< HEAD
    // DEV MODE FLAGS
    devMode: true,
    showDebugInfo: true
=======
    // Game stats
    enemiesKilled: 0, bestCombo: 0, bossesKilled: 0, totalDashes: 0, perfectDashes: 0,
    // Control mode
    mouseMode: true
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
  };

  /* ====== UI refs ====== */
  const ui={
    score:$('#score'), combo:$('#combo'), best:$('#best'), daily:$('#daily'),
<<<<<<< HEAD
=======
    controlMode:$('#controlMode'),
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
    overlay:$('#overlay'),
    ovTitle:$('#overlayTitle'), ovBody:$('#overlayBody'),
    start:$('#start'), dailyBtn:$('#dailyBtn'),
    btnResume:$('#btnResume'), btnPlayAgain:$('#btnPlayAgain'), btnShare:$('#btnShare'),
    lbBtn:$('#lbBtn'), nameInput:$('#nameInput'),
    restartBtn:$('#restartBtn'), shareBtn:$('#shareBtn'),
<<<<<<< HEAD
    dailyBanner:$('#dailyBanner')
  };

  function hydrateHUD(){ ui.score.textContent='Score: 0'; ui.combo.textContent='Combo: 0'; ui.best.textContent='Best: '+state.best; ui.daily.textContent='Daily: '+state.dailyBest; }
  hydrateHUD();
  ui.dailyBanner.textContent = 'DEV Daily: ' + new Date().toISOString().slice(0,10);
=======
    dailyBanner:$('#dailyBanner'),
    gameStats:$('#gameStats'),
    statEnemiesKilled:$('#statEnemiesKilled'), statBestCombo:$('#statBestCombo'),
    statBossesKilled:$('#statBossesKilled'), statTotalDashes:$('#statTotalDashes'),
    statPerfectDashes:$('#statPerfectDashes'), statGameTime:$('#statGameTime')
  };

  function hydrateHUD(){ 
    ui.score.textContent='Score: 0'; 
    ui.combo.textContent='Combo: 0'; 
    ui.best.textContent='Best: '+state.best; 
    ui.daily.textContent='Daily: '+state.dailyBest;
    ui.controlMode.textContent = state.mouseMode ? 'Mouse: ON' : 'Keyboard: ON';
  }
  hydrateHUD();
  ui.dailyBanner.textContent = 'Daily Challenge: ' + new Date().toISOString().slice(0,10);
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e

  /* ====== Pause/Resume helpers (overlay driven) ====== */
  function showOverlay(){ ui.overlay.classList.add('visible'); }
  function hideOverlay(){ ui.overlay.classList.remove('visible'); }

  function setOverlayHome(){
    ui.ovTitle.textContent = 'Loop Runner DEV';
<<<<<<< HEAD
    ui.ovBody.innerHTML = 'ðŸš§ Development Version - Testing new features! ðŸš§<br><br>Dash through enemies. Click/tap to dash toward the pointer. Chain kills to build combo. Don\'t touch enemies while not dashing.';
    ui.btnResume.style.display = 'none';
    ui.btnPlayAgain.style.display = 'none';
=======
    ui.ovBody.textContent = 'Dash through enemies. Click/tap to dash toward the pointer. Chain kills to build combo. Don\'t touch enemies while not dashing.';
    ui.btnResume.style.display = 'none';
    ui.btnPlayAgain.style.display = 'none';
    ui.gameStats.style.display = 'none';
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
    showOverlay();
  }
  function setOverlayPaused(){
    ui.ovTitle.textContent = 'Paused';
    ui.ovBody.innerHTML = 'Press <b>P</b> or <b>Esc</b> to resume';
    ui.btnResume.style.display = '';
    ui.btnPlayAgain.style.display = '';
<<<<<<< HEAD
    showOverlay();
  }
  function setOverlayGameOver(score, best, isPB){
    const stats = `
      <div style="text-align: center; margin: 10px 0;">
        <div style="font-size: 16px; margin-bottom: 8px;">Score: <b>${score}</b> â€¢ Best: <b>${best}</b>${isPB?' â€¢ ðŸŽ‰':''}</div>
        <div style="font-size: 13px; opacity: 0.8; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
          <div>Enemies Killed: <b>${gameStats.enemiesKilled}</b></div>
          <div>Best Combo: <b>${gameStats.bestCombo}</b></div>
          <div>Total Dashes: <b>${gameStats.totalDashes}</b></div>
          <div>Bosses Killed: <b>${gameStats.bossesKilled}</b></div>
          <div>Perfect Dashes: <b>${gameStats.perfectDashes}</b></div>
          <div>Game Time: <b>${gameStats.gameTime.toFixed(1)}s</b></div>
        </div>
      </div>
    `;
    ui.ovTitle.textContent = isPB ? 'New Best!' : 'Game Over';
    ui.ovBody.innerHTML = stats;
    ui.btnResume.style.display = 'none';
    ui.btnPlayAgain.style.display = '';
=======
    ui.gameStats.style.display = 'none';
    showOverlay();
  }
  function setOverlayGameOver(score, best, isPB){
    ui.ovTitle.textContent = isPB ? 'New Best!' : 'Game Over';
    ui.ovBody.innerHTML = `Score: <b>${score}</b> â€¢ Best: <b>${best}</b>${isPB?' â€¢ ðŸŽ‰':''}`;
    ui.btnResume.style.display = 'none';
    ui.btnPlayAgain.style.display = '';
    
    // Update and show game stats
    ui.statEnemiesKilled.textContent = state.enemiesKilled;
    ui.statBestCombo.textContent = state.bestCombo;
    ui.statBossesKilled.textContent = state.bossesKilled;
    ui.statTotalDashes.textContent = state.totalDashes;
    ui.statPerfectDashes.textContent = state.perfectDashes;
    ui.statGameTime.textContent = Math.floor(state.time) + 's';
    ui.gameStats.style.display = '';
    
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
    showOverlay();
  }

  /* ====== RNG ====== */
  const todayKey=()=>new Date().toISOString().slice(0,10);
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}};
  let seededRand=Math.random; let usingSeed=false;
  function setDailySeed(){ usingSeed=true; seededRand=mulberry32(hashToInt('looprunner:'+todayKey())); }
  function rnd(a=0,b=1){ return (usingSeed?seededRand():Math.random())*(b-a)+a; }
  function rndi(a,b){ return Math.floor(rnd(a,b+1)); }
  function hashToInt(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619); } return h>>>0; }

  /* ====== Audio ====== */
  let audio, master;
<<<<<<< HEAD
  function initAudio(){ 
    if(!audio){ 
      audio=new (window.AudioContext||window.webkitAudioContext)(); 
      master=audio.createGain(); 
      master.gain.value=0.08; 
      master.connect(audio.destination); 
    } 
  }
  
  // Enhanced Audio System
  const audioSettings = { enabled: true, volume: 0.3 };
  
  function playTone(freq, duration, type='sine', volume=1) {
    if (!audio || !audioSettings.enabled) return;
    const osc = audio.createOscillator();
    const gain = audio.createGain();
    osc.connect(gain);
    gain.connect(master);
    osc.frequency.value = freq;
    osc.type = type;
    gain.gain.value = volume * audioSettings.volume;
    gain.gain.exponentialRampToValueAtTime(0.01, audio.currentTime + duration);
    osc.start();
    osc.stop(audio.currentTime + duration);
  }
  
  function playDashSound() { playTone(440, 0.1, 'square', 0.3); }
  function playKillSound(combo) { 
    const freq = 220 + (combo * 50);
    playTone(freq, 0.15, 'sawtooth', 0.4); 
  }
  function playComboSound(combo) {
    for(let i = 0; i < Math.min(combo, 5); i++) {
      setTimeout(() => playTone(440 + i * 110, 0.1, 'sine', 0.2), i * 50);
    }
  }
  function playGameOverSound() { playTone(110, 0.5, 'triangle', 0.5); }

  /* ====== Entities ====== */
  const player={ x:W/2, y:H/2, r:12, vx:0, vy:0, maxSpeed:900, friction:9, dashing:false, dashCooldown:0, dashWindup:0 };
  const enemies=[]; const particles=[]; const powerups=[]; const projectiles=[];
  
  // Visual effects system
  let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
  let comboDisplay = { scale: 1, alpha: 1, text: '', timer: 0 };
  let dashTrail = [];
  let backgroundParticles = [];
  
  // Game statistics
  const gameStats = {
    enemiesKilled: 0,
    bestCombo: 0,
    totalDashes: 0,
    bossesKilled: 0,
    perfectDashes: 0,
    gameTime: 0
  };
  
  // Power-up types
  const POWERUP_TYPES = {
    SHIELD: { color: '#88ccff', duration: 3, icon: 'ðŸ›¡ï¸' },
    SPEED: { color: '#ffcc88', duration: 2, icon: 'âš¡' },
    MULTIDASH: { color: '#cc88ff', duration: 4, icon: 'ðŸ’«' },
    SLOWMO: { color: '#ff88cc', duration: 2, icon: 'â°' },
    FIREBURST: { color: '#ff6666', duration: 1, icon: 'ðŸ”¥' }
  };
  
  // Player power-up state
  const playerPowers = {
    shield: 0,
    speed: 0,
    multidash: 0,
    slowmo: 0,
    fireburst: 0
  };
  
  // Enemy types
  const ENEMY_TYPES = {
    NORMAL: { color: 'speed', size: 1, speed: 1, points: 10 },
    FAST: { color: '#ff6666', size: 0.8, speed: 1.5, points: 20 },
    BIG: { color: '#6666ff', size: 1.4, speed: 0.7, points: 30 },
    BONUS: { color: '#ffff66', size: 1.2, speed: 1.2, points: 50 },
    BOSS: { color: '#ff3333', size: 2.5, speed: 0.5, points: 200, health: 5 }
  };
  
  // Chain dash system
  let chainDashTargets = [];
  let chainDashActive = false;
  
  // Background effects
  function initBackgroundParticles() {
    backgroundParticles = [];
=======
  function initAudio(){ if(!audio){ audio=new (window.AudioContext||window.webkitAudioContext)(); master=audio.createGain(); master.gain.value=0.08; master.connect(audio.destination); } }

  /* ====== Entities ====== */
  const player={ x:W/2, y:H/2, r:12, vx:0, vy:0, maxSpeed:900, friction:9, dashing:false, dashCooldown:0, dashWindup:0 };
  const enemies=[];
  const bosses=[];
  const particles=[];
  const projectiles=[];
  const powerUps=[];
  const backgroundParticles=[];

  // Initialize background particles
  function initBackgroundParticles() {
    backgroundParticles.length = 0;
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
    for(let i = 0; i < 50; i++) {
      backgroundParticles.push({
        x: rnd(0, W),
        y: rnd(0, H),
        vx: rnd(-20, 20),
        vy: rnd(-20, 20),
        size: rnd(1, 3),
<<<<<<< HEAD
        alpha: rnd(0.1, 0.3),
        color: `hsl(${rnd(200, 280)}, 50%, 70%)`
=======
        opacity: rnd(0.1, 0.3),
        color: `hsl(${rnd(200, 280)}, 70%, 60%)`
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
      });
    }
  }

<<<<<<< HEAD
  function addParticle(x,y,size=2,life=0.4,color='#8fb3ff'){ 
    const a=rnd(0,Math.PI*2); 
    const sp=rnd(40,240); 
    particles.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life, maxLife:life, size, color}); 
  }
  
  function addComboParticles(x, y, combo) {
    const colors = ['#88ffcc', '#ffcc88', '#ff88cc', '#cc88ff', '#88ccff'];
    const color = colors[Math.min(combo - 1, colors.length - 1)];
    for(let i = 0; i < Math.min(combo * 3, 20); i++) {
      addParticle(x, y, rnd(2, 5), rnd(0.3, 0.8), color);
    }
  }
  
  function addDashParticles(x, y) {
    for(let i = 0; i < 15; i++) {
      addParticle(x, y, rnd(1, 3), rnd(0.2, 0.4), '#88ffcc');
    }
  }
  
  function addScreenShake(intensity, duration) {
    screenShake.intensity = Math.max(screenShake.intensity, intensity);
    screenShake.duration = Math.max(screenShake.duration, duration);
  }
  
  function updateComboDisplay(combo) {
    comboDisplay.scale = 1.5;
    comboDisplay.alpha = 1;
    comboDisplay.text = `x${combo} COMBO!`;
    comboDisplay.timer = 1.0;
  }
  
  function addDashTrail(x, y) {
    dashTrail.push({ x, y, life: 0.3, maxLife: 0.3 });
    if(dashTrail.length > 10) dashTrail.shift();
  }
  
  function fireBurst() {
    const burstCount = 10;
    for(let i = 0; i < burstCount; i++) {
      const angle = (Math.PI * 2 / burstCount) * i;
      const speed = 400;
      projectiles.push({
        x: player.x,
        y: player.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 2,
        maxLife: 2,
        size: 4,
        damage: 1
      });
    }
    addScreenShake(5, 0.2);
    playComboSound(3);
  }
  
  function spawnPowerup() {
    if(powerups.length >= 2) return; // Max 2 powerups on screen
    const types = Object.keys(POWERUP_TYPES);
    const type = types[rndi(0, types.length - 1)];
    const x = rnd(50, W - 50);
    const y = rnd(50, H - 50);
    powerups.push({ x, y, type, life: 10, maxLife: 10, collected: false });
  }
  
  function spawnBoss() {
    if(enemies.some(e => e.type === 'BOSS')) return; // Only one boss at a time
    const side = rndi(0, 3);
    const m = 50;
    let x, y;
    if(side === 0) { x = rnd(m, W - m); y = -m; }
    else if(side === 1) { x = W + m; y = rnd(m, H - m); }
    else if(side === 2) { x = rnd(m, W - m); y = H + m; }
    else { x = -m; y = rnd(m, H - m); }
    
    const type = ENEMY_TYPES.BOSS;
    const r = 40;
    const speed = 30;
    const ang = Math.atan2(player.y - y, player.x - x);
    const vx = Math.cos(ang) * speed;
    const vy = Math.sin(ang) * speed;
    
    enemies.push({
      x, y, r, vx, vy, speed, ang, 
      type: 'BOSS', 
      points: type.points,
      health: type.health,
      maxHealth: type.health
    });
  }
  
=======
  function addParticle(x,y,size=2,life=0.4){ 
    const a=rnd(0,Math.PI*2); 
    const sp=rnd(40,240); 
    particles.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life, maxLife:life, size}); 
  }

>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
  function spawnEnemy(){ 
    const m=24; 
    const side=rndi(0,3); 
    let x,y; 
    if(side===0){x=rnd(-m,W+m); y=-m;} 
    else if(side===1){x=W+m; y=rnd(-m,H+m);} 
    else if(side===2){x=rnd(-m,W+m); y=H+m;} 
    else {x=-m; y=rnd(-m,H+m);} 
    
<<<<<<< HEAD
    // Boss spawn chance
    if(state.score > 1000 && rnd(0, 100) < 2) {
      spawnBoss();
      return;
    }
    
    // Determine enemy type based on score
    let enemyType = 'NORMAL';
    const rand = rnd(0, 100);
    if(state.score > 500) {
      if(rand < 10) enemyType = 'BONUS';
      else if(rand < 30) enemyType = 'BIG';
      else if(rand < 60) enemyType = 'FAST';
    } else if(state.score > 200) {
      if(rand < 20) enemyType = 'FAST';
      else if(rand < 35) enemyType = 'BIG';
    }
    
    const type = ENEMY_TYPES[enemyType];
    const r = rnd(14, 22) * type.size;
    const baseSpeed = rnd(40, 90) + Math.min(state.time * 4, 220);
    const speed = baseSpeed * type.speed;
    const ang = Math.atan2(player.y - y, player.x - x) + rnd(-0.5, 0.5);
    const vx = Math.cos(ang) * speed;
    const vy = Math.sin(ang) * speed;
    
    enemies.push({
      x, y, r, vx, vy, speed, ang, 
      type: enemyType, 
      points: type.points,
      health: enemyType === 'BIG' ? 2 : 1,
      maxHealth: enemyType === 'BIG' ? 2 : 1
    });
  }

  /* ====== Input ====== */
  let pointer={ x:W/2, y:H/2, down:false };
  let mouseControls = true; // Enable mouse controls by default
  
  function screenToWorld(e){ const rect=canvas.getBoundingClientRect(); return { x:(e.clientX-rect.left), y:(e.clientY-rect.top) }; }
  
  function findChainTargets(startX, startY, maxDistance = 150) {
    const targets = [];
    for(const enemy of enemies) {
      const dist = Math.hypot(enemy.x - startX, enemy.y - startY);
      if(dist <= maxDistance) {
        targets.push({ enemy, distance: dist });
      }
    }
    return targets.sort((a, b) => a.distance - b.distance).slice(0, 5);
  }
  
  function startDashTowards(px,py){ 
    if(player.dashCooldown>0) return; 
    
    gameStats.totalDashes++;
    
    // Check for chain dash opportunity
    const chainTargets = findChainTargets(player.x, player.y);
    if(chainTargets.length > 1) {
      chainDashTargets = chainTargets;
      chainDashActive = true;
    }
    
    // Multi-dash power-up allows multiple dashes
    const dashCount = playerPowers.multidash > 0 ? 3 : 1;
    
    for(let i = 0; i < dashCount; i++) {
      setTimeout(() => {
        if(i === 0) {
          const dx=px-player.x, dy=py-player.y; 
          const len=Math.hypot(dx,dy)||1; 
          const ux=dx/len, uy=dy/len;
          const speedMultiplier = playerPowers.speed > 0 ? 1.5 : 1;
          player.vx=ux*player.maxSpeed*speedMultiplier; 
          player.vy=uy*player.maxSpeed*speedMultiplier; 
          player.dashing=true; 
          player.dashCooldown=0.35; 
          player.dashWindup=0.12; 
          addDashParticles(player.x, player.y);
          addScreenShake(2, 0.1);
          playDashSound();
          
          // Fire burst activation
          if(playerPowers.fireburst > 0) {
            fireBurst();
            playerPowers.fireburst = 0; // Single use
          }
        } else {
          // Additional dashes for multi-dash
          const angle = (Math.PI * 2 / dashCount) * i;
          const dx = Math.cos(angle) * 100;
          const dy = Math.sin(angle) * 100;
          addDashParticles(player.x + dx, player.y + dy);
        }
      }, i * 100);
    }
  }
  
  // Original single dash logic (keeping for compatibility)
  function startDashTowardsOrig(px,py){ 
    if(player.dashCooldown>0) return; 
    const dx=px-player.x, dy=py-player.y; 
    const len=Math.hypot(dx,dy)||1; 
    const ux=dx/len, uy=dy/len; 
    const speedMultiplier = playerPowers.speed > 0 ? 1.5 : 1;
    player.vx=ux*player.maxSpeed*speedMultiplier; 
    player.vy=uy*player.maxSpeed*speedMultiplier; 
    player.dashing=true; 
    player.dashCooldown=0.35; 
    player.dashWindup=0.12; 
    addDashParticles(player.x, player.y);
    addScreenShake(2, 0.1);
    playDashSound();
  }
  
  // Mouse controls
  canvas.addEventListener('pointerdown',(e)=>{ 
    initAudio(); 
    if(mouseControls) {
      const p=screenToWorld(e); 
      pointer.down=true; 
      pointer.x=p.x; 
      pointer.y=p.y; 
      startDashTowards(pointer.x,pointer.y);
    }
  });
  canvas.addEventListener('pointermove',(e)=>{ 
    if(mouseControls) {
      const p=screenToWorld(e); 
      pointer.x=p.x; 
      pointer.y=p.y; 
    }
  });
  canvas.addEventListener('pointerup',()=>{ pointer.down=false; });
  
  // Right click for fire burst
  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if(mouseControls && state.running && !state.paused) {
      fireBurst();
    }
  });

  addEventListener('keydown',(e)=>{
    if(e.repeat) return;
    if(e.code==='Space'){ if(!state.running){ e.preventDefault(); startGame(state.dailyMode); return; } }
    if(e.key==='r' || e.key==='R'){ e.preventDefault(); startGame(state.dailyMode); return; }
    if(e.key==='p' || e.key==='P' || e.key==='Escape'){ e.preventDefault(); if(state.running){ if(!state.paused) pauseGameUI(); else resumeGameUI(); } return; }
    const amt=80; if(e.key&&e.key.indexOf('Arrow')===0){ let dx=0, dy=0; if(e.key==='ArrowUp') dy=-amt; else if(e.key==='ArrowDown') dy=amt; else if(e.key==='ArrowLeft') dx=-amt; else if(e.key==='ArrowRight') dx=amt; startDashTowardsOrig(player.x+dx, player.y+dy);} 
    
    // Fire burst with F key
    if(e.key==='f' || e.key==='F'){ e.preventDefault(); if(state.running && !state.paused) fireBurst(); }
    
    // Toggle mouse controls
    if(e.key==='c' || e.key==='C'){ mouseControls = !mouseControls; console.log('Mouse controls:', mouseControls ? 'ON' : 'OFF'); }
    
    // Audio controls
    if(e.key==='m' || e.key==='M'){ audioSettings.enabled = !audioSettings.enabled; console.log('Audio:', audioSettings.enabled ? 'ON' : 'OFF'); }
  });
=======
    const r=rnd(14,22); 
    const speed=rnd(40,90)+Math.min(state.time*4,220); 
    const ang=Math.atan2(player.y-y, player.x-x)+rnd(-0.5,0.5); 
    const vx=Math.cos(ang)*speed, vy=Math.sin(ang)*speed; 
    
    // Chance for boss enemy after score 1000
    if(state.score > 1000 && rnd(0,100) < 2) {
      bosses.push({
        x,y,r:r*2.5,vx,vy,speed:speed*0.7,ang,
        health: 5, maxHealth: 5, isBoss: true
      });
    } else {
      // Chance for big enemy
      const isBig = rnd(0,100) < 15;
      enemies.push({
        x,y,r:isBig ? r*1.5 : r,vx,vy,speed,ang,
        health: isBig ? 2 : 1, maxHealth: isBig ? 2 : 1, isBig
      });
    }
  }

  function createProjectile(x, y, angle, speed = 300) {
    projectiles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 2.0,
      size: 3
    });
  }

  function fireBurst(x, y) {
    for(let i = 0; i < 10; i++) {
      const angle = (i / 10) * Math.PI * 2;
      createProjectile(x, y, angle);
    }
    // Add burst effect particles
    for(let i = 0; i < 20; i++) {
      addParticle(x, y, rnd(2, 4), rnd(0.3, 0.6));
    }
  }

  /* ====== Input ====== */
  let pointer={ x:W/2, y:H/2, down:false };
  let mousePos = { x: W/2, y: H/2 };

  function screenToWorld(e){ 
    const rect=canvas.getBoundingClientRect(); 
    return { x:(e.clientX-rect.left), y:(e.clientY-rect.top) }; 
  }

  function startDashTowards(px,py){ 
    if(player.dashCooldown>0) return; 
    const dx=px-player.x, dy=py-player.y; 
    const len=Math.hypot(dx,dy)||1; 
    const ux=dx/len, uy=dy/len; 
    player.vx=ux*player.maxSpeed; 
    player.vy=uy*player.maxSpeed; 
    player.dashing=true; 
    player.dashCooldown=0.35; 
    player.dashWindup=0.12; 
    state.totalDashes++;
    
    for(let i=0;i<10;i++) addParticle(player.x,player.y,3,0.25); 
  }

  // Mouse controls
  canvas.addEventListener('pointerdown',(e)=>{ 
    if(!state.mouseMode) return;
    initAudio(); 
    const p=screenToWorld(e); 
    pointer.down=true; 
    pointer.x=p.x; 
    pointer.y=p.y; 
    
    if(e.button === 2) { // Right click
      e.preventDefault();
      fireBurst(player.x, player.y);
    } else {
      startDashTowards(pointer.x,pointer.y); 
    }
  });

  canvas.addEventListener('pointermove',(e)=>{ 
    const p=screenToWorld(e); 
    pointer.x=p.x; 
    pointer.y=p.y; 
    mousePos = p;
  });

  canvas.addEventListener('pointerup',()=>{ pointer.down=false; });
  canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent right-click menu

  // Keyboard controls
  addEventListener('keydown',(e)=>{
    if(e.repeat) return;
    
    // Toggle control mode
    if(e.key==='c' || e.key==='C') {
      state.mouseMode = !state.mouseMode;
      ui.controlMode.textContent = state.mouseMode ? 'Mouse: ON' : 'Keyboard: ON';
      return;
    }
    
    // Fire burst
    if(e.key==='f' || e.key==='F') {
      e.preventDefault();
      fireBurst(player.x, player.y);
      return;
    }
    
    if(e.code==='Space'){ 
      if(!state.running){ 
        e.preventDefault(); 
        startGame(state.dailyMode); 
        return; 
      } 
    }
    if(e.key==='r' || e.key==='R'){ 
      e.preventDefault(); 
      startGame(state.dailyMode); 
      return; 
    }
    if(e.key==='p' || e.key==='P' || e.key==='Escape'){ 
      e.preventDefault(); 
      if(state.running){ 
        if(!state.paused) pauseGameUI(); 
        else resumeGameUI(); 
      } 
      return; 
    }
    
    // Arrow key dashing (keyboard mode)
    if(!state.mouseMode) {
      const amt=80; 
      if(e.key&&e.key.indexOf('Arrow')===0){ 
        let dx=0, dy=0; 
        if(e.key==='ArrowUp') dy=-amt; 
        else if(e.key==='ArrowDown') dy=amt; 
        else if(e.key==='ArrowLeft') dx=-amt; 
        else if(e.key==='ArrowRight') dx=amt; 
        startDashTowards(player.x+dx, player.y+dy);
      }
    }
  });

>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
  addEventListener('blur', ()=>{ if(state.running && !state.paused) pauseGameUI(); });

  /* ====== Leaderboard ====== */
  const lb={ modal:$('#lbModal'), close:$('#lbClose'), modeSel:$('#lbMode'), info:$('#lbInfo'), table:$('#lbTable').querySelector('tbody') };
  function loadLB(key){ try{ return JSON.parse(getLS(key,'[]')); }catch{ return []; } }
  function saveLB(key,arr){ setLS(key, JSON.stringify(arr)); }

  const SB_URL = 'https://zpoerliqhcywaulbthyf.supabase.co/rest/v1/scores';
  const SB_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpwb2VybGlxaGN5d2F1bGJ0aHlmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgyMDQxNjYsImV4cCI6MjA3Mzc4MDE2Nn0.7jjITj1H2AxWPnCeyzmMsNw3uAVACoYb_CV5rRoD65k';
  const SB_HEADERS = { 'apikey': SB_KEY, 'Authorization': 'Bearer '+SB_KEY, 'Content-Type': 'application/json' };

  function showLeaderboard(mode){ lb.modal.classList.add('show'); lb.modeSel.value = mode || (state.dailyMode?'daily':'normal'); renderLeaderboard(); maybeFillModalAd(); }
  function hideLeaderboard(){ lb.modal.classList.remove('show'); }

  function renderLeaderboard(){
    const mode = lb.modeSel.value;
<<<<<<< HEAD
    
    // DEV MODE: Always use local scores first
    lb.table.innerHTML = '';
    
    const key = mode==='daily' ? ('lr_lb_daily_'+todayKey()) : 'lr_lb_normal';
    const arr = loadLB(key);
    lb.info.textContent = 'Development Leaderboard (Local Scores)';
    
    arr.slice(0,10).forEach((e,i) => {
      const tr = document.createElement('tr');
      const when = e.when ? new Date(e.when).toLocaleString() : 'Unknown';
      tr.innerHTML = `<td>${i+1}</td><td>${escapeHtml(e.name)}</td><td>${e.score}</td><td style="text-align:right;opacity:.8">${when}</td>`;
      lb.table.appendChild(tr);
    });
    
    if (arr.length===0){
      const tr=document.createElement('tr');
      tr.innerHTML='<td colspan="4" style="opacity:.7;">No dev scores yet. Play a game to see your scores here!</td>';
      lb.table.appendChild(tr);
    }
=======
    const params = new URLSearchParams();
    params.append('select', 'name,score');
    params.append('order',  'score.desc');
    params.append('limit',  '10');

    lb.table.innerHTML = '';
    lb.info.textContent = 'Worldwide Top 10 (score only)';

    fetch(`${SB_URL}?${params.toString()}`, { headers: SB_HEADERS })
      .then(res => { if (!res.ok) throw new Error('REST '+res.status); return res.json(); })
      .then(rows => {
        rows.slice(0,10).forEach((e,i) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${i+1}</td><td>${escapeHtml(e.name||'anon')}</td><td>${e.score|0}</td><td style="text-align:right;opacity:.8">â€”</td>`;
          lb.table.appendChild(tr);
        });
        if (rows.length === 0) {
          const tr = document.createElement('tr');
          tr.innerHTML = '<td colspan="4" style="opacity:.7;">No scores yet. Be the first!</td>';
          lb.table.appendChild(tr);
        }
      })
      .catch(() => {
        const key = mode==='daily' ? ('lr_lb_daily_'+todayKey()) : 'lr_lb_normal';
        const arr = loadLB(key);
        lb.info.textContent += ' â€¢ offline';
        lb.table.innerHTML = '';
        arr.slice(0,10).forEach((e,i) => {
          const tr = document.createElement('tr');
          const when = new Date(e.when).toLocaleString();
          tr.innerHTML = `<td>${i+1}</td><td>${escapeHtml(e.name)}</td><td>${e.score}</td><td style="text-align:right;opacity:.8">${when}</td>`;
          lb.table.appendChild(tr);
        });
        if (arr.length===0){
          const tr=document.createElement('tr');
          tr.innerHTML='<td colspan="4" style="opacity:.7;">No scores yet. Play a run!</td>';
          lb.table.appendChild(tr);
        }
      });
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
  }
  function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c])); }
  lb.close.addEventListener('click', hideLeaderboard);
  lb.modeSel.addEventListener('change', renderLeaderboard);
  ui.lbBtn.addEventListener('click', ()=> showLeaderboard());

  let modalAdFilled = false;
  function maybeFillModalAd(){
    if(modalAdFilled) return;
    const ins = document.getElementById('ad-modal-unit');
    if(!ins) return;
    const w = ins.clientWidth;
    if(w && w>0){ (window.adsbygoogle=window.adsbygoogle||[]).push({}); modalAdFilled = true; }
    else { setTimeout(maybeFillModalAd, 200); }
  }

  /* ====== Share (overlay + quickbar) ====== */
  async function doShare(){
    const url = location.href;
<<<<<<< HEAD
    const text = `I just played Loop Runner and scored ${state.score|0}!`;
    try{
      if (navigator.share){ await navigator.share({ title:'Loop Runner', text, url }); }
=======
    const text = `I just played Loop Runner DEV and scored ${state.score|0}!`;
    try{
      if (navigator.share){ await navigator.share({ title:'Loop Runner DEV', text, url }); }
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
      else {
        await navigator.clipboard.writeText(url);
        alert('Link copied to clipboard!');
      }
    }catch(e){ /* user cancelled */ }
  }

  /* ====== Game control ====== */
  function startGame(daily=false){
<<<<<<< HEAD
    state.running=true; state.paused=false; state.time=0; state.score=0; state.combo=0; state.spawnTimer=0; state.spawnInterval=1.1; 
    enemies.length=0; particles.length=0; powerups.length=0; dashTrail.length=0; projectiles.length=0;
    player.x=W/2; player.y=H/2; player.vx=0; player.vy=0; player.dashing=false; player.dashCooldown=0; player.dashWindup=0; 
    // Reset power-ups
    Object.keys(playerPowers).forEach(key => playerPowers[key] = 0);
    // Reset stats
    Object.keys(gameStats).forEach(key => gameStats[key] = 0);
    // Reset chain dash
    chainDashTargets = [];
    chainDashActive = false;
    // Initialize background
    initBackgroundParticles();
    hydrateHUD(); state.dailyMode=daily; usingSeed=false; if(daily) setDailySeed(); hideOverlay();
  }
  function gameOver(){
    state.running=false; state.paused=false;
    const score = state.score|0;
    gameStats.gameTime = state.time;
    let isPB = false;
    if(state.dailyMode){ if(score > state.dailyBest){ state.dailyBest = score; setLS('lr_daily', state.dailyBest); isPB = true; } }
    else { if(score > state.best){ state.best = score; setLS('lr_best', state.best); isPB = true; } }
    hydrateHUD();
    setOverlayGameOver(score, state.dailyMode?state.dailyBest:state.best, isPB);
    submitScore();
    playGameOverSound();
    showLeaderboard(state.dailyMode?'daily':'normal');
    if (isPB) setTimeout(() => { try{ doShare(); }catch(e){} }, 450);
=======
    console.log('Starting game...', daily ? 'daily mode' : 'normal mode');
    
    // Reset all game state
    state.running=true; 
    state.paused=false; 
    state.time=0; 
    state.score=0; 
    state.combo=0; 
    state.spawnTimer=0; 
    state.spawnInterval=1.1; 
    state.enemiesKilled = 0;
    state.bestCombo = 0;
    state.bossesKilled = 0;
    state.totalDashes = 0;
    state.perfectDashes = 0;
    
    // Clear all arrays
    enemies.length=0; 
    bosses.length=0;
    particles.length=0; 
    projectiles.length=0;
    powerUps.length=0;
    
    // Reset player
    player.x=W/2; 
    player.y=H/2; 
    player.vx=0; 
    player.vy=0; 
    player.dashing=false; 
    player.dashCooldown=0; 
    player.dashWindup=0; 
    
    hydrateHUD(); 
    state.dailyMode=daily; 
    usingSeed=false; 
    if(daily) setDailySeed(); 
    
    // Initialize background particles
    initBackgroundParticles();
    
    hideOverlay();
    console.log('Game started successfully');
  }

  function gameOver(){
    console.log('Game over');
    state.running=false; 
    state.paused=false;
    const score = state.score|0;
    let isPB = false;
    
    // Update best combo
    if(state.combo > state.bestCombo) {
      state.bestCombo = state.combo;
    }
    
    if(state.dailyMode){ 
      if(score > state.dailyBest){ 
        state.dailyBest = score; 
        setLS('lr_daily', state.dailyBest); 
        isPB = true; 
      } 
    } else { 
      if(score > state.best){ 
        state.best = score; 
        setLS('lr_best', state.best); 
        isPB = true; 
      } 
    }
    
    hydrateHUD();
    setOverlayGameOver(score, state.dailyMode?state.dailyBest:state.best, isPB);
    submitScore();
    showLeaderboard(state.dailyMode?'daily':'normal');
    if (isPB) setTimeout(()=>{ try{ doShare(); }catch(e){} }, 450);
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
  }

  function pauseGameUI(){ if (!state.running || state.paused) return; state.paused = true; setOverlayPaused(); }
  function resumeGameUI(){ if (!state.paused) return; state.paused = false; hideOverlay(); }

  async function submitScore(){
<<<<<<< HEAD
    const name=(ui.nameInput.value||getLS('lr_name','DevPlayer')).slice(0,20).trim()||'DevPlayer';
    setLS('lr_name',name);
    
    // In dev mode, don't submit to live leaderboard
    console.log('DEV MODE: Would submit score:', { name, score: state.score|0, mode: state.dailyMode ? 'daily' : 'normal' });
    // DEV MODE: Still save locally for offline leaderboard testing
    // DEV MODE: Still save locally for offline leaderboard testing
    const key = state.dailyMode ? ('lr_lb_daily_'+todayKey()) : 'lr_lb_normal';
    const arr = loadLB(key);
    const entry = { name, score: state.score|0, when: new Date().toISOString() };
    arr.push(entry);
    arr.sort((a,b) => b.score - a.score);
    if(arr.length > 50) arr.length = 50;
    saveLB(key, arr);
    saveLB(key, arr);
=======
    const name=(ui.nameInput.value||getLS('lr_name','Player')).slice(0,20).trim()||'Player';
    setLS('lr_name',name);
    try {
      const body = { name: name.slice(0,12), score: state.score|0, mode: (state.dailyMode ? 'daily' : 'normal') };
      fetch(SB_URL, { method:'POST', headers: { ...SB_HEADERS, Prefer: 'return=minimal' }, body: JSON.stringify(body) })
        .then(async r => { if(!r.ok){ let txt=''; try{ txt = await r.text(); }catch(e){} console.error('Supabase insert failed', r.status, txt); } })
        .catch(err => console.error('Supabase insert network error', err));
    } catch(err) { console.error('submitScore exception', err); }
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
  }

  ui.start.addEventListener('click', ()=>{ initAudio(); startGame(false); });
  ui.dailyBtn.addEventListener('click', ()=>{ initAudio(); startGame(true); });
  ui.btnResume.addEventListener('click', resumeGameUI);
<<<<<<< HEAD
  ui.btnPlayAgain.addEventListener('click', ()=> { initAudio(); startGame(state.dailyMode); });
  ui.btnShare.addEventListener('click', doShare);
  ui.restartBtn.addEventListener('click', ()=> { initAudio(); startGame(state.dailyMode); });
  ui.shareBtn.addEventListener('click', doShare);

  /* ====== Loop ====== */
  let last = performance.now();
  let powerupSpawnTimer = 0;
  
  function loop(){
    requestAnimationFrame(loop);
    const t=performance.now(); let dt=(t-last)/1000; last=t;
    
    // Apply slow-motion effect
    if(playerPowers.slowmo > 0) dt *= 0.5;
    
    if(!state.running || state.paused){ render(); return; }
    state.time += dt; state.score += dt*10; if(((state.score|0)%10)===0) ui.score.textContent=`Score: ${state.score|0}`;
    update(dt); render();
  }

  function update(dt){
    // Update background particles
    for(const p of backgroundParticles) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if(p.x < -10) p.x = W + 10;
      if(p.x > W + 10) p.x = -10;
      if(p.y < -10) p.y = H + 10;
      if(p.y > H + 10) p.y = -10;
    }
    
    // Update power-up timers
    Object.keys(playerPowers).forEach(key => {
      if(playerPowers[key] > 0) {
        playerPowers[key] -= dt;
        if(playerPowers[key] <= 0) playerPowers[key] = 0;
      }
    });
    
    // Spawn power-ups occasionally
    powerupSpawnTimer -= dt;
    if(powerupSpawnTimer <= 0 && state.score > 100) {
      if(rnd(0, 100) < 15) spawnPowerup(); // 15% chance
      powerupSpawnTimer = rnd(3, 8); // Reset timer
    }
    
    state.spawnTimer-=dt; if(state.spawnTimer<=0){ spawnEnemy(); state.spawnTimer=state.spawnInterval; }
    if(player.dashWindup>0){ player.dashWindup-=dt; if(player.dashWindup<=0) player.dashing=false; }
    
    // Update visual effects
    if(screenShake.duration > 0) {
      screenShake.duration -= dt;
      screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
      screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
      if(screenShake.duration <= 0) {
        screenShake.x = screenShake.y = screenShake.intensity = 0;
      }
    }
    
    if(comboDisplay.timer > 0) {
      comboDisplay.timer -= dt;
      comboDisplay.scale = lerp(comboDisplay.scale, 1, dt * 3);
      comboDisplay.alpha = comboDisplay.timer / 1.0;
    }
    
    // Update dash trail
    if(player.dashing) {
      addDashTrail(player.x, player.y);
    }
    for(let i = 0; i < dashTrail.length; i++) {
      dashTrail[i].life -= dt;
      if(dashTrail[i].life <= 0) {
        dashTrail.splice(i, 1);
        i--;
      }
    }
=======
  ui.btnPlayAgain.addEventListener('click', ()=> startGame(state.dailyMode));
  ui.btnShare.addEventListener('click', doShare);
  ui.restartBtn.addEventListener('click', ()=> startGame(state.dailyMode));
  ui.shareBtn.addEventListener('click', doShare);

  /* ====== Chain Dash System ====== */
  function findChainTargets(playerX, playerY, dashVx, dashVy) {
    const chainTargets = [];
    const dashDir = Math.atan2(dashVy, dashVx);
    const chainRange = 80;
    
    // Check enemies
    enemies.forEach(enemy => {
      const dist = Math.hypot(enemy.x - playerX, enemy.y - playerY);
      if(dist < chainRange) {
        const angleToEnemy = Math.atan2(enemy.y - playerY, enemy.x - playerX);
        const angleDiff = Math.abs(dashDir - angleToEnemy);
        if(angleDiff < Math.PI/3) { // 60 degree cone
          chainTargets.push(enemy);
        }
      }
    });
    
    // Check bosses
    bosses.forEach(boss => {
      const dist = Math.hypot(boss.x - playerX, boss.y - playerY);
      if(dist < chainRange) {
        const angleToEnemy = Math.atan2(boss.y - playerY, boss.x - playerX);
        const angleDiff = Math.abs(dashDir - angleToEnemy);
        if(angleDiff < Math.PI/3) {
          chainTargets.push(boss);
        }
      }
    });
    
    return chainTargets.slice(0, 5); // Max 5 chain targets
  }

  /* ====== Loop ====== */
  let last = performance.now();
  function loop(){
    requestAnimationFrame(loop);
    const t=performance.now(); 
    let dt=(t-last)/1000; 
    last=t;
    
    if(!state.running || state.paused){ 
      render(); 
      return; 
    }
    
    state.time += dt; 
    state.score += dt*10; 
    if(((state.score|0)%10)===0) ui.score.textContent=`Score: ${state.score|0}`;

    // ---- Depth handoff at 350 points ----
    if (!depthKick && (state.score|0) >= 350) {
      depthKick = true;
      try { localStorage.setItem('lr_depth_unlocked', '1'); } catch(e) {}
      setTimeout(() => { window.location.assign(DEPTH_URL); }, 250);
    }

    update(dt); 
    render();
  }

  function update(dt){
    // Spawn enemies
    state.spawnTimer-=dt; 
    if(state.spawnTimer<=0){ 
      spawnEnemy(); 
      state.spawnTimer=state.spawnInterval; 
    }
    
    // Update player
    if(player.dashWindup>0){ 
      player.dashWindup-=dt; 
      if(player.dashWindup<=0) player.dashing=false; 
    }
    const f=Math.exp(-player.friction*dt); 
    player.vx*=f; 
    player.vy*=f; 
    player.x+=player.vx*dt; 
    player.y+=player.vy*dt; 
    player.x=Math.max(8,Math.min(W-8,player.x)); 
    player.y=Math.max(8,Math.min(H-8,player.y)); 
    if(player.dashCooldown>0) player.dashCooldown-=dt;
    
    // Update background particles
    backgroundParticles.forEach(p => {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      
      // Wrap around screen
      if(p.x < 0) p.x = W;
      if(p.x > W) p.x = 0;
      if(p.y < 0) p.y = H;
      if(p.y > H) p.y = 0;
    });
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
    
    // Update projectiles
    for(let i = 0; i < projectiles.length; i++) {
      const proj = projectiles[i];
      proj.life -= dt;
      proj.x += proj.vx * dt;
      proj.y += proj.vy * dt;
      
<<<<<<< HEAD
      // Check projectile-enemy collision
=======
      if(proj.life <= 0 || proj.x < 0 || proj.x > W || proj.y < 0 || proj.y > H) {
        projectiles.splice(i, 1);
        i--;
        continue;
      }
      
      // Check projectile vs enemies
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
      for(let j = 0; j < enemies.length; j++) {
        const enemy = enemies[j];
        const dist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
        if(dist < enemy.r + proj.size) {
<<<<<<< HEAD
          // Hit enemy
          enemy.health = (enemy.health || 1) - proj.damage;
          addParticle(proj.x, proj.y, 3, 0.3, '#ff6666');
=======
          enemy.health--;
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
          projectiles.splice(i, 1);
          i--;
          
          if(enemy.health <= 0) {
<<<<<<< HEAD
            // Kill enemy
            const points = enemy.points || 10;
            state.score += points;
            gameStats.enemiesKilled++;
            if(enemy.type === 'BOSS') gameStats.bossesKilled++;
            addComboParticles(enemy.x, enemy.y, 1);
            enemies.splice(j, 1);
            playKillSound(1);
=======
            enemies.splice(j, 1);
            state.enemiesKilled++;
            state.combo++;
            const add = Math.floor(10 * Math.pow(1.4, state.combo-1));
            state.score += add;
            ui.combo.textContent = `Combo: ${state.combo}`;
            ui.score.textContent = `Score: ${state.score|0}`;
            
            for(let k=0; k<15; k++) addParticle(enemy.x, enemy.y, Math.random()*2+2, Math.random()*0.4+0.2);
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
          }
          break;
        }
      }
      
<<<<<<< HEAD
      if(proj.life <= 0 || proj.x < -50 || proj.x > W + 50 || proj.y < -50 || proj.y > H + 50) {
        projectiles.splice(i, 1);
        i--;
      }
    }
    
    const f=Math.exp(-player.friction*dt); player.vx*=f; player.vy*=f; player.x+=player.vx*dt; player.y+=player.vy*dt; player.x=Math.max(8,Math.min(W-8,player.x)); player.y=Math.max(8,Math.min(H-8,player.y)); if(player.dashCooldown>0) player.dashCooldown-=dt;
    
    // Check power-up collection
    for(let i = 0; i < powerups.length; i++) {
      const p = powerups[i];
      p.life -= dt;
      const d = Math.hypot(p.x - player.x, p.y - player.y);
      if(d < 25) {
        // Collect power-up
        playerPowers[p.type.toLowerCase()] = POWERUP_TYPES[p.type].duration;
        addParticle(p.x, p.y, 4, 0.8, POWERUP_TYPES[p.type].color);
        powerups.splice(i, 1);
        i--;
        playComboSound(2);
      } else if(p.life <= 0) {
        powerups.splice(i, 1);
        i--;
      }
    }
    
    for(let i=0;i<enemies.length;i++){
      const e=enemies[i];
      const ang=Math.atan2(player.y-e.y, player.x-e.x); e.vx=Math.cos(ang)*e.speed; e.vy=Math.sin(ang)*e.speed; e.ang = Math.atan2(e.vy, e.vx); e.x+=e.vx*dt; e.y+=e.vy*dt;
      const d=Math.hypot(e.x-player.x, e.y-player.y);
      if(d<e.r+player.r){
        if(player.dashing || playerPowers.shield > 0){ 
          // Damage enemy
          e.health = (e.health || 1) - 1;
          
          if(e.health <= 0) {
            enemies.splice(i,1); i--; 
            state.combo+=1; 
            const basePoints = e.points || 10;
            const add = Math.floor(basePoints * Math.pow(1.4, state.combo-1)); 
            state.score += add; 
            ui.combo.textContent=`Combo: ${state.combo}`; 
            ui.score.textContent=`Score: ${state.score|0}`;
            
            // Enhanced visual feedback for kills
            addComboParticles(e.x, e.y, state.combo);
            addScreenShake(Math.min(state.combo * 0.5, 8), 0.15);
            updateComboDisplay(state.combo);
            playKillSound(state.combo);
            
            // Trigger slow-mo on high combos
            if(state.combo >= 5 && state.combo % 5 === 0) {
              playerPowers.slowmo = Math.max(playerPowers.slowmo, 1.5);
            // Enhanced visual feedback for kills
            addComboParticles(e.x, e.y, state.combo);
            addScreenShake(Math.min(state.combo * 0.5, 8), 0.15);
            updateComboDisplay(state.combo);
            playKillSound(state.combo);
            
            // Trigger slow-mo on high combos
            if(state.combo >= 5 && state.combo % 5 === 0) {
              playerPowers.slowmo = Math.max(playerPowers.slowmo, 1.5);
            }
            
            // Track stats
            gameStats.enemiesKilled++;
            if(state.combo > gameStats.bestCombo) {
              gameStats.bestCombo = state.combo;
            }
            if(e.type === 'BOSS') {
              gameStats.bossesKilled++;
            }
        }
        else if(playerPowers.shield <= 0) { 
          gameOver(); break; 
        }
      }
=======
      // Check projectile vs bosses
      for(let j = 0; j < bosses.length; j++) {
        const boss = bosses[j];
        const dist = Math.hypot(proj.x - boss.x, proj.y - boss.y);
        if(dist < boss.r + proj.size) {
          boss.health--;
          projectiles.splice(i, 1);
          i--;
          
          if(boss.health <= 0) {
            bosses.splice(j, 1);
            state.bossesKilled++;
            state.enemiesKilled++;
            state.combo += 5; // Bonus combo for boss
            const add = 200; // Fixed boss points
            state.score += add;
            ui.combo.textContent = `Combo: ${state.combo}`;
            ui.score.textContent = `Score: ${state.score|0}`;
            
            for(let k=0; k<30; k++) addParticle(boss.x, boss.y, Math.random()*4+3, Math.random()*0.6+0.3);
          }
          break;
        }
      }
    }
    
    // Update enemies
    for(let i=0;i<enemies.length;i++){
      const e=enemies[i];
      const ang=Math.atan2(player.y-e.y, player.x-e.x); 
      e.vx=Math.cos(ang)*e.speed; 
      e.vy=Math.sin(ang)*e.speed; 
      e.ang = Math.atan2(e.vy, e.vx); 
      e.x+=e.vx*dt; 
      e.y+=e.vy*dt;
      
      const d=Math.hypot(e.x-player.x, e.y-player.y);
      if(d<e.r+player.r){
        if(player.dashing){ 
          enemies.splice(i,1); 
          i--; 
          state.enemiesKilled++;
          state.combo+=1; 
          const add = Math.floor(10*Math.pow(1.4, state.combo-1)); 
          state.score += add; 
          ui.combo.textContent=`Combo: ${state.combo}`; 
          ui.score.textContent=`Score: ${state.score|0}`; 
          for(let k=0;k<24;k++) addParticle(e.x,e.y, Math.random()*2+2, Math.random()*0.4+0.2); 
        } else { 
          gameOver(); 
          break; 
        }
      }
      if(e.x<-100||e.x>W+100||e.y<-100||e.y>H+100){ enemies.splice(i,1); i--; }
    }
    
    // Update bosses
    for(let i=0;i<bosses.length;i++){
      const boss=bosses[i];
      const ang=Math.atan2(player.y-boss.y, player.x-boss.x); 
      boss.vx=Math.cos(ang)*boss.speed; 
      boss.vy=Math.sin(ang)*boss.speed; 
      boss.ang = Math.atan2(boss.vy, boss.vx); 
      boss.x+=boss.vx*dt; 
      boss.y+=boss.vy*dt;
      
      const d=Math.hypot(boss.x-player.x, boss.y-player.y);
      if(d<boss.r+player.r){
        if(player.dashing){ 
          boss.health--;
          if(boss.health <= 0) {
            bosses.splice(i,1); 
            i--; 
            state.bossesKilled++;
            state.enemiesKilled++;
            state.combo+=5; // Bonus combo for boss
            const add = 200; // Fixed boss points
            state.score += add; 
            ui.combo.textContent=`Combo: ${state.combo}`; 
            ui.score.textContent=`Score: ${state.score|0}`; 
            for(let k=0;k<30;k++) addParticle(boss.x,boss.y, Math.random()*4+3, Math.random()*0.6+0.3);
          } else {
            // Boss took damage but didn't die
            for(let k=0;k<10;k++) addParticle(boss.x,boss.y, Math.random()*3+2, Math.random()*0.3+0.2);
          }
        } else { 
          gameOver(); 
          break; 
        }
      }
      if(boss.x<-150||boss.x>W+150||boss.y<-150||boss.y>H+150){ bosses.splice(i,1); i--; }
    }
    
    // Update particles
    for(let i=0;i<particles.length;i++){ 
      const p=particles[i]; 
      p.life-=dt; 
      p.x+=p.vx*dt; 
      p.y+=p.vy*dt; 
      p.vx*=0.98; 
      p.vy*=0.98; 
      if(p.life<=0){ particles.splice(i,1); i--; } 
    }
  }

  /* ====== Visuals ====== */
  function clamp01(t){ return Math.max(0, Math.min(1, t)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpColor(c1, c2, t){
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
    return [
      Math.round(lerp(c1[0], c2[0], t)),
      Math.round(lerp(c1[1], c2[1], t)),
      Math.round(lerp(c1[2], c2[2], t))
    ];
  }
  const COL_BLUE=[88,166,255], COL_YELLOW=[255,210,119], COL_RED=[255,95,95];
  function speedToColor(speed){
    const t = clamp01((speed-40)/270);
    if(t<0.5){
      const u=t/0.5; const c=lerpColor(COL_BLUE, COL_YELLOW, u);
      return `rgb(${c[0]},${c[1]},${c[2]})`;
    } else {
      const u=(t-0.5)/0.5; const c=lerpColor(COL_YELLOW, COL_RED, u);
      return `rgb(${c[0]},${c[1]},${c[2]})`;
    }
  }
<<<<<<< HEAD
  
  function drawDot(e){
    let fill;
    if(e.type && ENEMY_TYPES[e.type] && ENEMY_TYPES[e.type].color !== 'speed') {
      fill = ENEMY_TYPES[e.type].color;
    } else {
      fill = speedToColor(e.speed);
    }
    
    ctx.save();
=======

  function drawEntity(e, isBoss = false){
    const fill = speedToColor(e.speed);
    ctx.save();
    
    // Draw health bar for damaged entities
    if(e.health < e.maxHealth) {
      const barWidth = e.r * 2;
      const barHeight = 4;
      const barX = e.x - barWidth/2;
      const barY = e.y - e.r - 10;
      
      // Background
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      // Health fill
      const healthPercent = e.health / e.maxHealth;
      ctx.fillStyle = healthPercent > 0.5 ? '#4ade80' : healthPercent > 0.25 ? '#fbbf24' : '#ef4444';
      ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
    }
    
    // Draw crown for bosses
    if(isBoss) {
      ctx.fillStyle = '#ffd700';
      ctx.font = `${e.r/2}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText('ðŸ‘‘', e.x, e.y - e.r - 5);
    }
    
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
    ctx.fillStyle = fill;
    ctx.shadowColor = fill;
<<<<<<< HEAD
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
    ctx.stroke();
    
    // Draw type indicator for special enemies
    if(e.type && e.type !== 'NORMAL') {
      ctx.fillStyle = '#fff';
      ctx.font = `${Math.min(e.r * 0.8, 16)}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const symbols = { FAST: 'âš¡', BIG: 'â—', BONUS: 'â˜…', BOSS: 'ðŸ‘‘' };
      ctx.fillText(symbols[e.type] || '?', e.x, e.y);
    }
    
    // Draw health bar for damaged enemies
    if(e.health && e.maxHealth && e.health < e.maxHealth) {
      const barWidth = e.r * 2;
      const barHeight = 4;
      const healthPercent = e.health / e.maxHealth;
      
      ctx.fillStyle = '#ff3333';
      ctx.fillRect(e.x - barWidth/2, e.y - e.r - 10, barWidth, barHeight);
      ctx.fillStyle = '#33ff33';
      ctx.fillRect(e.x - barWidth/2, e.y - e.r - 10, barWidth * healthPercent, barHeight);
    }
    
    ctx.restore();
  }
  
  function render(){
    ctx.save();
    
    // Apply screen shake
    ctx.translate(screenShake.x, screenShake.y);
    
    ctx.clearRect(0,0,W,H);
    
    // Draw animated background
    for(const p of backgroundParticles) {
      ctx.save();
      ctx.globalAlpha = p.alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.fill();
      ctx.restore();
    }
    
    // DEV MODE: Draw debug grid
    if(state.showDebugInfo){
      ctx.strokeStyle = 'rgba(255, 107, 107, 0.1)';
      ctx.lineWidth = 1;
      for(let x = 0; x < W; x += 50){
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for(let y = 0; y < H; y += 50){
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }
    }
    
    // Draw dash trail
    for(const trail of dashTrail) {
      const alpha = trail.life / trail.maxLife;
      ctx.save();
      ctx.globalAlpha = alpha * 0.6;
      ctx.beginPath();
      ctx.arc(trail.x, trail.y, 8, 0, Math.PI * 2);
      ctx.fillStyle = '#88ffcc';
      ctx.fill();
      ctx.restore();
    }
    
    // Draw projectiles
    for(const proj of projectiles) {
      const alpha = proj.life / proj.maxLife;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
      ctx.fillStyle = '#ff6666';
      ctx.shadowColor = '#ff6666';
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.restore();
    }
    
=======
    ctx.shadowBlur = isBoss ? 15 : 8;
    ctx.fill();
    ctx.lineWidth = isBoss ? 3 : 2;
    ctx.strokeStyle = isBoss ? 'rgba(255,215,0,0.8)' : 'rgba(0,0,0,0.45)';
    ctx.stroke();
    ctx.restore();
  }

  function render(){
    ctx.save();
    ctx.clearRect(0,0,W,H);
    
    // Draw background particles
    backgroundParticles.forEach(p => {
      ctx.save();
      ctx.globalAlpha = p.opacity;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fillStyle = p.color;
      ctx.fill();
      ctx.restore();
    });
    
    // Draw game particles
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
    for(const p of particles){
      const a=Math.max(0, Math.min(1, p.life/p.maxLife));
      ctx.globalAlpha=a;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
<<<<<<< HEAD
      ctx.fillStyle=p.color || '#8fb3ff';
=======
      ctx.fillStyle='#8fb3ff';
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
      ctx.fill();
      ctx.globalAlpha=1;
    }
    
<<<<<<< HEAD
    for(const e of enemies){ drawDot(e); }
    
    // Draw power-ups
    for(const p of powerups) {
      const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
      ctx.save();
      ctx.globalAlpha = pulse;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 15, 0, Math.PI * 2);
      ctx.fillStyle = POWERUP_TYPES[p.type].color;
      ctx.shadowColor = POWERUP_TYPES[p.type].color;
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw icon
      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(POWERUP_TYPES[p.type].icon, p.x, p.y);
      ctx.restore();
    }
    
    // Enhanced player rendering
    ctx.beginPath();
    ctx.arc(player.x,player.y,player.r,0,Math.PI*2);
    
    // Player color based on power-ups
    let playerColor = '#e6edf3';
    if(playerPowers.shield > 0) playerColor = '#88ccff';
    else if(playerPowers.speed > 0) playerColor = '#ffcc88';
    else if(playerPowers.multidash > 0) playerColor = '#cc88ff';
    else if(player.dashing) playerColor = '#88ffcc';
    
    ctx.fillStyle = playerColor;
    ctx.shadowColor = playerColor;
    ctx.shadowBlur = (player.dashing || Object.values(playerPowers).some(p => p > 0)) ? 12 : 0;
    ctx.fill();
    
    // Draw dash cooldown indicator
    if(player.dashCooldown > 0) {
      const cooldownPercent = player.dashCooldown / 0.35;
      ctx.save();
      ctx.strokeStyle = '#ff6b6b';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r + 4, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * (1 - cooldownPercent)));
      ctx.stroke();
      ctx.restore();
    }
    
    // Draw combo display
    if(comboDisplay.timer > 0) {
      ctx.save();
      ctx.globalAlpha = comboDisplay.alpha;
      ctx.font = `bold ${16 * comboDisplay.scale}px system-ui`;
      ctx.fillStyle = '#ffcc88';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeText(comboDisplay.text, W/2, H/2 - 60);
      ctx.fillText(comboDisplay.text, W/2, H/2 - 60);
      ctx.restore();
    }
    
    // Draw chain dash indicators
    if(chainDashActive && chainDashTargets.length > 0) {
=======
    // Draw projectiles
    projectiles.forEach(proj => {
      ctx.save();
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI*2);
      ctx.fillStyle = '#ff6b6b';
      ctx.shadowColor = '#ff6b6b';
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.restore();
    });
    
    // Draw enemies
    for(const e of enemies){ drawEntity(e); }
    
    // Draw bosses
    for(const boss of bosses){ drawEntity(boss, true); }
    
    // Draw chain dash indicators
    if(player.dashing && state.mouseMode) {
      const chainTargets = findChainTargets(player.x, player.y, player.vx, player.vy);
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
      ctx.save();
      ctx.strokeStyle = '#88ffcc';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
<<<<<<< HEAD
      for(const target of chainDashTargets) {
        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(target.enemy.x, target.enemy.y);
        ctx.stroke();
      }
      ctx.restore();
    }
    
    // Draw power-up status
    let yOffset = 20;
    Object.keys(playerPowers).forEach(power => {
      if(playerPowers[power] > 0) {
        ctx.fillStyle = '#fff';
        ctx.font = '14px Arial';
        ctx.fillText(`${power.toUpperCase()}: ${playerPowers[power].toFixed(1)}s`, W - 150, yOffset);
        yOffset += 20;
      }
    });
    
    // DEV MODE: Show debug info
    if(state.showDebugInfo && state.running){
      ctx.fillStyle = '#ff6b6b';
      ctx.font = '12px monospace';
      let debugY = H - 150;
      ctx.fillText(`DEV: Enemies: ${enemies.length}`, 10, debugY += 15);
      ctx.fillText(`DEV: Particles: ${particles.length}`, 10, debugY += 15);
      ctx.fillText(`DEV: Projectiles: ${projectiles.length}`, 10, debugY += 15);
      ctx.fillText(`DEV: Time: ${state.time.toFixed(1)}s`, 10, debugY += 15);
      ctx.fillText(`DEV: Chain Dash: ${chainDashActive}`, 10, debugY += 15);
      ctx.fillText(`DEV: Mouse: ${mouseControls ? 'ON' : 'OFF'} (C to toggle)`, 10, debugY += 15);
      ctx.fillText(`DEV: Audio: ${audioSettings.enabled ? 'ON' : 'OFF'} (M to toggle)`, 10, debugY += 15);
      ctx.fillText(`DEV: Controls: F=FireBurst, RClick=FireBurst`, 10, debugY += 15);
    }
    
=======
      chainTargets.forEach(target => {
        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
      });
      ctx.restore();
    }
    
    // Draw mouse cursor indicator (mouse mode only)
    if(state.mouseMode && state.running && !state.paused) {
      ctx.save();
      ctx.strokeStyle = '#6cf';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(mousePos.x, mousePos.y, 8, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
    
    // Draw player
    ctx.beginPath();
    ctx.arc(player.x,player.y,player.r,0,Math.PI*2);
    ctx.fillStyle= player.dashing ? '#88ffcc' : '#e6edf3';
    ctx.shadowColor = player.dashing ? '#88ffcc' : '#0000';
    ctx.shadowBlur = player.dashing ? 12 : 0;

  /* ====== Modal close-click ====== */

  /* ====== Boot ====== */
  resize();
<<<<<<< HEAD
  requestAnimationFrame(function loopStart(){ requestAnimationFrame(loop); });
  setOverlayHome();
  
  // DEV MODE: Add console info
  console.log('ðŸš§ Loop Runner Development Mode Active ðŸš§');
  console.log('Features:');
  console.log('- Separate localStorage (dev_ prefix)');
  console.log('- Debug grid and info display');
  console.log('- Scores not submitted to live leaderboard');
  console.log('- Visual dev mode indicators');
  console.log('- Press M to toggle audio');
  console.log('- Press C to toggle mouse controls');
  console.log('- Press F or Right-click for fire burst');
  console.log('- Boss enemies spawn after score 1000');
  console.log('- Chain dash through multiple enemies');
  console.log('- Detailed game statistics on game over');
=======
  initBackgroundParticles();
  requestAnimationFrame(function loopStart(){ requestAnimationFrame(loop); });
  setOverlayHome();
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
})();
</script>

<script>
  // No-scroll hardening for touch devices
  function preventScroll(e){ e.preventDefault(); }
  window.addEventListener('touchmove', preventScroll, { passive:false });
  window.addEventListener('wheel', preventScroll, { passive:false });
</script>
</body>
<<<<<<< HEAD
</html>
=======
    #overlayCard{ min-width:min(85%,520px); max-width:92%; border-radius:16px; padding:16px 18px; background:var(--card); box-shadow:0 10px 30px rgba(0,0,0,.35); outline:1px
>>>>>>> c5ada410dffd64da5f60078b0cf4c120d0ebc483
=======
</html>
>>>>>>> eaa82ab3fd858a8ae89851e1262668015fe4742e
